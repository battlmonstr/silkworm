// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remote/kv.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_remote_2fkv_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_remote_2fkv_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include "types/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_remote_2fkv_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_remote_2fkv_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_remote_2fkv_2eproto;
namespace remote {
class AccountChange;
struct AccountChangeDefaultTypeInternal;
extern AccountChangeDefaultTypeInternal _AccountChange_default_instance_;
class Cursor;
struct CursorDefaultTypeInternal;
extern CursorDefaultTypeInternal _Cursor_default_instance_;
class HistoryGetReply;
struct HistoryGetReplyDefaultTypeInternal;
extern HistoryGetReplyDefaultTypeInternal _HistoryGetReply_default_instance_;
class HistoryGetReq;
struct HistoryGetReqDefaultTypeInternal;
extern HistoryGetReqDefaultTypeInternal _HistoryGetReq_default_instance_;
class IndexRangeReply;
struct IndexRangeReplyDefaultTypeInternal;
extern IndexRangeReplyDefaultTypeInternal _IndexRangeReply_default_instance_;
class IndexRangeReq;
struct IndexRangeReqDefaultTypeInternal;
extern IndexRangeReqDefaultTypeInternal _IndexRangeReq_default_instance_;
class Pair;
struct PairDefaultTypeInternal;
extern PairDefaultTypeInternal _Pair_default_instance_;
class SnapshotsReply;
struct SnapshotsReplyDefaultTypeInternal;
extern SnapshotsReplyDefaultTypeInternal _SnapshotsReply_default_instance_;
class SnapshotsRequest;
struct SnapshotsRequestDefaultTypeInternal;
extern SnapshotsRequestDefaultTypeInternal _SnapshotsRequest_default_instance_;
class StateChange;
struct StateChangeDefaultTypeInternal;
extern StateChangeDefaultTypeInternal _StateChange_default_instance_;
class StateChangeBatch;
struct StateChangeBatchDefaultTypeInternal;
extern StateChangeBatchDefaultTypeInternal _StateChangeBatch_default_instance_;
class StateChangeRequest;
struct StateChangeRequestDefaultTypeInternal;
extern StateChangeRequestDefaultTypeInternal _StateChangeRequest_default_instance_;
class StorageChange;
struct StorageChangeDefaultTypeInternal;
extern StorageChangeDefaultTypeInternal _StorageChange_default_instance_;
}  // namespace remote
PROTOBUF_NAMESPACE_OPEN
template<> ::remote::AccountChange* Arena::CreateMaybeMessage<::remote::AccountChange>(Arena*);
template<> ::remote::Cursor* Arena::CreateMaybeMessage<::remote::Cursor>(Arena*);
template<> ::remote::HistoryGetReply* Arena::CreateMaybeMessage<::remote::HistoryGetReply>(Arena*);
template<> ::remote::HistoryGetReq* Arena::CreateMaybeMessage<::remote::HistoryGetReq>(Arena*);
template<> ::remote::IndexRangeReply* Arena::CreateMaybeMessage<::remote::IndexRangeReply>(Arena*);
template<> ::remote::IndexRangeReq* Arena::CreateMaybeMessage<::remote::IndexRangeReq>(Arena*);
template<> ::remote::Pair* Arena::CreateMaybeMessage<::remote::Pair>(Arena*);
template<> ::remote::SnapshotsReply* Arena::CreateMaybeMessage<::remote::SnapshotsReply>(Arena*);
template<> ::remote::SnapshotsRequest* Arena::CreateMaybeMessage<::remote::SnapshotsRequest>(Arena*);
template<> ::remote::StateChange* Arena::CreateMaybeMessage<::remote::StateChange>(Arena*);
template<> ::remote::StateChangeBatch* Arena::CreateMaybeMessage<::remote::StateChangeBatch>(Arena*);
template<> ::remote::StateChangeRequest* Arena::CreateMaybeMessage<::remote::StateChangeRequest>(Arena*);
template<> ::remote::StorageChange* Arena::CreateMaybeMessage<::remote::StorageChange>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace remote {

enum Op : int {
  FIRST = 0,
  FIRST_DUP = 1,
  SEEK = 2,
  SEEK_BOTH = 3,
  CURRENT = 4,
  LAST = 6,
  LAST_DUP = 7,
  NEXT = 8,
  NEXT_DUP = 9,
  NEXT_NO_DUP = 11,
  PREV = 12,
  PREV_DUP = 13,
  PREV_NO_DUP = 14,
  SEEK_EXACT = 15,
  SEEK_BOTH_EXACT = 16,
  OPEN = 30,
  CLOSE = 31,
  OPEN_DUP_SORT = 32,
  COUNT = 33,
  Op_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Op_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Op_IsValid(int value);
constexpr Op Op_MIN = FIRST;
constexpr Op Op_MAX = COUNT;
constexpr int Op_ARRAYSIZE = Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Op_descriptor();
template<typename T>
inline const std::string& Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Op_descriptor(), enum_t_value);
}
inline bool Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Op>(
    Op_descriptor(), name, value);
}
enum Action : int {
  STORAGE = 0,
  UPSERT = 1,
  CODE = 2,
  UPSERT_CODE = 3,
  REMOVE = 4,
  Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Action_IsValid(int value);
constexpr Action Action_MIN = STORAGE;
constexpr Action Action_MAX = REMOVE;
constexpr int Action_ARRAYSIZE = Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor();
template<typename T>
inline const std::string& Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Action_descriptor(), enum_t_value);
}
inline bool Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
enum Direction : int {
  FORWARD = 0,
  UNWIND = 1,
  Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = FORWARD;
constexpr Direction Direction_MAX = UNWIND;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor();
template<typename T>
inline const std::string& Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Direction_descriptor(), enum_t_value);
}
inline bool Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
// ===================================================================

class Cursor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.Cursor) */ {
 public:
  inline Cursor() : Cursor(nullptr) {}
  ~Cursor() override;
  explicit PROTOBUF_CONSTEXPR Cursor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cursor(const Cursor& from);
  Cursor(Cursor&& from) noexcept
    : Cursor() {
    *this = ::std::move(from);
  }

  inline Cursor& operator=(const Cursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cursor& operator=(Cursor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cursor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cursor* internal_default_instance() {
    return reinterpret_cast<const Cursor*>(
               &_Cursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Cursor& a, Cursor& b) {
    a.Swap(&b);
  }
  inline void Swap(Cursor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cursor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cursor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cursor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cursor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cursor& from) {
    Cursor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cursor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.Cursor";
  }
  protected:
  explicit Cursor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketNameFieldNumber = 2,
    kKFieldNumber = 4,
    kVFieldNumber = 5,
    kOpFieldNumber = 1,
    kCursorFieldNumber = 3,
  };
  // string bucketName = 2;
  void clear_bucketname();
  const std::string& bucketname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucketname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucketname();
  PROTOBUF_NODISCARD std::string* release_bucketname();
  void set_allocated_bucketname(std::string* bucketname);
  private:
  const std::string& _internal_bucketname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucketname(const std::string& value);
  std::string* _internal_mutable_bucketname();
  public:

  // bytes k = 4;
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // bytes v = 5;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // .remote.Op op = 1;
  void clear_op();
  ::remote::Op op() const;
  void set_op(::remote::Op value);
  private:
  ::remote::Op _internal_op() const;
  void _internal_set_op(::remote::Op value);
  public:

  // uint32 cursor = 3;
  void clear_cursor();
  uint32_t cursor() const;
  void set_cursor(uint32_t value);
  private:
  uint32_t _internal_cursor() const;
  void _internal_set_cursor(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.Cursor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucketname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
    int op_;
    uint32_t cursor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class Pair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.Pair) */ {
 public:
  inline Pair() : Pair(nullptr) {}
  ~Pair() override;
  explicit PROTOBUF_CONSTEXPR Pair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pair(const Pair& from);
  Pair(Pair&& from) noexcept
    : Pair() {
    *this = ::std::move(from);
  }

  inline Pair& operator=(const Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pair& operator=(Pair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pair& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pair* internal_default_instance() {
    return reinterpret_cast<const Pair*>(
               &_Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Pair& a, Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(Pair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pair& from) {
    Pair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.Pair";
  }
  protected:
  explicit Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKFieldNumber = 1,
    kVFieldNumber = 2,
    kViewIDFieldNumber = 4,
    kTxIDFieldNumber = 5,
    kCursorIDFieldNumber = 3,
  };
  // bytes k = 1;
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // bytes v = 2;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // uint64 viewID = 4;
  void clear_viewid();
  uint64_t viewid() const;
  void set_viewid(uint64_t value);
  private:
  uint64_t _internal_viewid() const;
  void _internal_set_viewid(uint64_t value);
  public:

  // uint64 txID = 5;
  void clear_txid();
  uint64_t txid() const;
  void set_txid(uint64_t value);
  private:
  uint64_t _internal_txid() const;
  void _internal_set_txid(uint64_t value);
  public:

  // uint32 cursorID = 3;
  void clear_cursorid();
  uint32_t cursorid() const;
  void set_cursorid(uint32_t value);
  private:
  uint32_t _internal_cursorid() const;
  void _internal_set_cursorid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.Pair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
    uint64_t viewid_;
    uint64_t txid_;
    uint32_t cursorid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class StorageChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.StorageChange) */ {
 public:
  inline StorageChange() : StorageChange(nullptr) {}
  ~StorageChange() override;
  explicit PROTOBUF_CONSTEXPR StorageChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageChange(const StorageChange& from);
  StorageChange(StorageChange&& from) noexcept
    : StorageChange() {
    *this = ::std::move(from);
  }

  inline StorageChange& operator=(const StorageChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageChange& operator=(StorageChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageChange* internal_default_instance() {
    return reinterpret_cast<const StorageChange*>(
               &_StorageChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StorageChange& a, StorageChange& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageChange& from) {
    StorageChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.StorageChange";
  }
  protected:
  explicit StorageChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kLocationFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .types.H256 location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::types::H256& location() const;
  PROTOBUF_NODISCARD ::types::H256* release_location();
  ::types::H256* mutable_location();
  void set_allocated_location(::types::H256* location);
  private:
  const ::types::H256& _internal_location() const;
  ::types::H256* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::types::H256* location);
  ::types::H256* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:remote.StorageChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::types::H256* location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class AccountChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.AccountChange) */ {
 public:
  inline AccountChange() : AccountChange(nullptr) {}
  ~AccountChange() override;
  explicit PROTOBUF_CONSTEXPR AccountChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountChange(const AccountChange& from);
  AccountChange(AccountChange&& from) noexcept
    : AccountChange() {
    *this = ::std::move(from);
  }

  inline AccountChange& operator=(const AccountChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountChange& operator=(AccountChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountChange* internal_default_instance() {
    return reinterpret_cast<const AccountChange*>(
               &_AccountChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccountChange& a, AccountChange& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountChange& from) {
    AccountChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.AccountChange";
  }
  protected:
  explicit AccountChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageChangesFieldNumber = 6,
    kDataFieldNumber = 4,
    kCodeFieldNumber = 5,
    kAddressFieldNumber = 1,
    kIncarnationFieldNumber = 2,
    kActionFieldNumber = 3,
  };
  // repeated .remote.StorageChange storageChanges = 6;
  int storagechanges_size() const;
  private:
  int _internal_storagechanges_size() const;
  public:
  void clear_storagechanges();
  ::remote::StorageChange* mutable_storagechanges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange >*
      mutable_storagechanges();
  private:
  const ::remote::StorageChange& _internal_storagechanges(int index) const;
  ::remote::StorageChange* _internal_add_storagechanges();
  public:
  const ::remote::StorageChange& storagechanges(int index) const;
  ::remote::StorageChange* add_storagechanges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange >&
      storagechanges() const;

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes code = 5;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // .types.H160 address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::types::H160& address() const;
  PROTOBUF_NODISCARD ::types::H160* release_address();
  ::types::H160* mutable_address();
  void set_allocated_address(::types::H160* address);
  private:
  const ::types::H160& _internal_address() const;
  ::types::H160* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::types::H160* address);
  ::types::H160* unsafe_arena_release_address();

  // uint64 incarnation = 2;
  void clear_incarnation();
  uint64_t incarnation() const;
  void set_incarnation(uint64_t value);
  private:
  uint64_t _internal_incarnation() const;
  void _internal_set_incarnation(uint64_t value);
  public:

  // .remote.Action action = 3;
  void clear_action();
  ::remote::Action action() const;
  void set_action(::remote::Action value);
  private:
  ::remote::Action _internal_action() const;
  void _internal_set_action(::remote::Action value);
  public:

  // @@protoc_insertion_point(class_scope:remote.AccountChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange > storagechanges_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::types::H160* address_;
    uint64_t incarnation_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class StateChangeBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.StateChangeBatch) */ {
 public:
  inline StateChangeBatch() : StateChangeBatch(nullptr) {}
  ~StateChangeBatch() override;
  explicit PROTOBUF_CONSTEXPR StateChangeBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateChangeBatch(const StateChangeBatch& from);
  StateChangeBatch(StateChangeBatch&& from) noexcept
    : StateChangeBatch() {
    *this = ::std::move(from);
  }

  inline StateChangeBatch& operator=(const StateChangeBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateChangeBatch& operator=(StateChangeBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateChangeBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateChangeBatch* internal_default_instance() {
    return reinterpret_cast<const StateChangeBatch*>(
               &_StateChangeBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StateChangeBatch& a, StateChangeBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(StateChangeBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateChangeBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateChangeBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateChangeBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateChangeBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateChangeBatch& from) {
    StateChangeBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateChangeBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.StateChangeBatch";
  }
  protected:
  explicit StateChangeBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeBatchFieldNumber = 2,
    kStateVersionIDFieldNumber = 1,
    kPendingBlockBaseFeeFieldNumber = 3,
    kBlockGasLimitFieldNumber = 4,
  };
  // repeated .remote.StateChange changeBatch = 2;
  int changebatch_size() const;
  private:
  int _internal_changebatch_size() const;
  public:
  void clear_changebatch();
  ::remote::StateChange* mutable_changebatch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange >*
      mutable_changebatch();
  private:
  const ::remote::StateChange& _internal_changebatch(int index) const;
  ::remote::StateChange* _internal_add_changebatch();
  public:
  const ::remote::StateChange& changebatch(int index) const;
  ::remote::StateChange* add_changebatch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange >&
      changebatch() const;

  // uint64 stateVersionID = 1;
  void clear_stateversionid();
  uint64_t stateversionid() const;
  void set_stateversionid(uint64_t value);
  private:
  uint64_t _internal_stateversionid() const;
  void _internal_set_stateversionid(uint64_t value);
  public:

  // uint64 pendingBlockBaseFee = 3;
  void clear_pendingblockbasefee();
  uint64_t pendingblockbasefee() const;
  void set_pendingblockbasefee(uint64_t value);
  private:
  uint64_t _internal_pendingblockbasefee() const;
  void _internal_set_pendingblockbasefee(uint64_t value);
  public:

  // uint64 blockGasLimit = 4;
  void clear_blockgaslimit();
  uint64_t blockgaslimit() const;
  void set_blockgaslimit(uint64_t value);
  private:
  uint64_t _internal_blockgaslimit() const;
  void _internal_set_blockgaslimit(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.StateChangeBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange > changebatch_;
    uint64_t stateversionid_;
    uint64_t pendingblockbasefee_;
    uint64_t blockgaslimit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class StateChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.StateChange) */ {
 public:
  inline StateChange() : StateChange(nullptr) {}
  ~StateChange() override;
  explicit PROTOBUF_CONSTEXPR StateChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateChange(const StateChange& from);
  StateChange(StateChange&& from) noexcept
    : StateChange() {
    *this = ::std::move(from);
  }

  inline StateChange& operator=(const StateChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateChange& operator=(StateChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateChange* internal_default_instance() {
    return reinterpret_cast<const StateChange*>(
               &_StateChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StateChange& a, StateChange& b) {
    a.Swap(&b);
  }
  inline void Swap(StateChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateChange& from) {
    StateChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.StateChange";
  }
  protected:
  explicit StateChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 4,
    kTxsFieldNumber = 5,
    kBlockHashFieldNumber = 3,
    kBlockHeightFieldNumber = 2,
    kDirectionFieldNumber = 1,
  };
  // repeated .remote.AccountChange changes = 4;
  int changes_size() const;
  private:
  int _internal_changes_size() const;
  public:
  void clear_changes();
  ::remote::AccountChange* mutable_changes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange >*
      mutable_changes();
  private:
  const ::remote::AccountChange& _internal_changes(int index) const;
  ::remote::AccountChange* _internal_add_changes();
  public:
  const ::remote::AccountChange& changes(int index) const;
  ::remote::AccountChange* add_changes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange >&
      changes() const;

  // repeated bytes txs = 5;
  int txs_size() const;
  private:
  int _internal_txs_size() const;
  public:
  void clear_txs();
  const std::string& txs(int index) const;
  std::string* mutable_txs(int index);
  void set_txs(int index, const std::string& value);
  void set_txs(int index, std::string&& value);
  void set_txs(int index, const char* value);
  void set_txs(int index, const void* value, size_t size);
  std::string* add_txs();
  void add_txs(const std::string& value);
  void add_txs(std::string&& value);
  void add_txs(const char* value);
  void add_txs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txs();
  private:
  const std::string& _internal_txs(int index) const;
  std::string* _internal_add_txs();
  public:

  // .types.H256 blockHash = 3;
  bool has_blockhash() const;
  private:
  bool _internal_has_blockhash() const;
  public:
  void clear_blockhash();
  const ::types::H256& blockhash() const;
  PROTOBUF_NODISCARD ::types::H256* release_blockhash();
  ::types::H256* mutable_blockhash();
  void set_allocated_blockhash(::types::H256* blockhash);
  private:
  const ::types::H256& _internal_blockhash() const;
  ::types::H256* _internal_mutable_blockhash();
  public:
  void unsafe_arena_set_allocated_blockhash(
      ::types::H256* blockhash);
  ::types::H256* unsafe_arena_release_blockhash();

  // uint64 blockHeight = 2;
  void clear_blockheight();
  uint64_t blockheight() const;
  void set_blockheight(uint64_t value);
  private:
  uint64_t _internal_blockheight() const;
  void _internal_set_blockheight(uint64_t value);
  public:

  // .remote.Direction direction = 1;
  void clear_direction();
  ::remote::Direction direction() const;
  void set_direction(::remote::Direction value);
  private:
  ::remote::Direction _internal_direction() const;
  void _internal_set_direction(::remote::Direction value);
  public:

  // @@protoc_insertion_point(class_scope:remote.StateChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange > changes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txs_;
    ::types::H256* blockhash_;
    uint64_t blockheight_;
    int direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class StateChangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.StateChangeRequest) */ {
 public:
  inline StateChangeRequest() : StateChangeRequest(nullptr) {}
  ~StateChangeRequest() override;
  explicit PROTOBUF_CONSTEXPR StateChangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateChangeRequest(const StateChangeRequest& from);
  StateChangeRequest(StateChangeRequest&& from) noexcept
    : StateChangeRequest() {
    *this = ::std::move(from);
  }

  inline StateChangeRequest& operator=(const StateChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateChangeRequest& operator=(StateChangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateChangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateChangeRequest* internal_default_instance() {
    return reinterpret_cast<const StateChangeRequest*>(
               &_StateChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StateChangeRequest& a, StateChangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StateChangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateChangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateChangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateChangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateChangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateChangeRequest& from) {
    StateChangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateChangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.StateChangeRequest";
  }
  protected:
  explicit StateChangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWithStorageFieldNumber = 1,
    kWithTransactionsFieldNumber = 2,
  };
  // bool withStorage = 1;
  void clear_withstorage();
  bool withstorage() const;
  void set_withstorage(bool value);
  private:
  bool _internal_withstorage() const;
  void _internal_set_withstorage(bool value);
  public:

  // bool withTransactions = 2;
  void clear_withtransactions();
  bool withtransactions() const;
  void set_withtransactions(bool value);
  private:
  bool _internal_withtransactions() const;
  void _internal_set_withtransactions(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.StateChangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool withstorage_;
    bool withtransactions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class SnapshotsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remote.SnapshotsRequest) */ {
 public:
  inline SnapshotsRequest() : SnapshotsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SnapshotsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotsRequest(const SnapshotsRequest& from);
  SnapshotsRequest(SnapshotsRequest&& from) noexcept
    : SnapshotsRequest() {
    *this = ::std::move(from);
  }

  inline SnapshotsRequest& operator=(const SnapshotsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotsRequest& operator=(SnapshotsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotsRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotsRequest*>(
               &_SnapshotsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SnapshotsRequest& a, SnapshotsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SnapshotsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SnapshotsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SnapshotsRequest";
  }
  protected:
  explicit SnapshotsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remote.SnapshotsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class SnapshotsReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.SnapshotsReply) */ {
 public:
  inline SnapshotsReply() : SnapshotsReply(nullptr) {}
  ~SnapshotsReply() override;
  explicit PROTOBUF_CONSTEXPR SnapshotsReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotsReply(const SnapshotsReply& from);
  SnapshotsReply(SnapshotsReply&& from) noexcept
    : SnapshotsReply() {
    *this = ::std::move(from);
  }

  inline SnapshotsReply& operator=(const SnapshotsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotsReply& operator=(SnapshotsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotsReply* internal_default_instance() {
    return reinterpret_cast<const SnapshotsReply*>(
               &_SnapshotsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SnapshotsReply& a, SnapshotsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotsReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotsReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotsReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotsReply& from) {
    SnapshotsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotsReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.SnapshotsReply";
  }
  protected:
  explicit SnapshotsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 1,
  };
  // repeated string files = 1;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  const std::string& files(int index) const;
  std::string* mutable_files(int index);
  void set_files(int index, const std::string& value);
  void set_files(int index, std::string&& value);
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  std::string* add_files();
  void add_files(const std::string& value);
  void add_files(std::string&& value);
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_files();
  private:
  const std::string& _internal_files(int index) const;
  std::string* _internal_add_files();
  public:

  // @@protoc_insertion_point(class_scope:remote.SnapshotsReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> files_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class HistoryGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.HistoryGetReq) */ {
 public:
  inline HistoryGetReq() : HistoryGetReq(nullptr) {}
  ~HistoryGetReq() override;
  explicit PROTOBUF_CONSTEXPR HistoryGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistoryGetReq(const HistoryGetReq& from);
  HistoryGetReq(HistoryGetReq&& from) noexcept
    : HistoryGetReq() {
    *this = ::std::move(from);
  }

  inline HistoryGetReq& operator=(const HistoryGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoryGetReq& operator=(HistoryGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistoryGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistoryGetReq* internal_default_instance() {
    return reinterpret_cast<const HistoryGetReq*>(
               &_HistoryGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HistoryGetReq& a, HistoryGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(HistoryGetReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoryGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistoryGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistoryGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistoryGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistoryGetReq& from) {
    HistoryGetReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoryGetReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.HistoryGetReq";
  }
  protected:
  explicit HistoryGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kKFieldNumber = 3,
    kTxIDFieldNumber = 1,
    kTsFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes k = 3;
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // uint64 txID = 1;
  void clear_txid();
  uint64_t txid() const;
  void set_txid(uint64_t value);
  private:
  uint64_t _internal_txid() const;
  void _internal_set_txid(uint64_t value);
  public:

  // uint64 ts = 4;
  void clear_ts();
  uint64_t ts() const;
  void set_ts(uint64_t value);
  private:
  uint64_t _internal_ts() const;
  void _internal_set_ts(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.HistoryGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    uint64_t txid_;
    uint64_t ts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class HistoryGetReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.HistoryGetReply) */ {
 public:
  inline HistoryGetReply() : HistoryGetReply(nullptr) {}
  ~HistoryGetReply() override;
  explicit PROTOBUF_CONSTEXPR HistoryGetReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistoryGetReply(const HistoryGetReply& from);
  HistoryGetReply(HistoryGetReply&& from) noexcept
    : HistoryGetReply() {
    *this = ::std::move(from);
  }

  inline HistoryGetReply& operator=(const HistoryGetReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoryGetReply& operator=(HistoryGetReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistoryGetReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistoryGetReply* internal_default_instance() {
    return reinterpret_cast<const HistoryGetReply*>(
               &_HistoryGetReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(HistoryGetReply& a, HistoryGetReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HistoryGetReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoryGetReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistoryGetReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistoryGetReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistoryGetReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistoryGetReply& from) {
    HistoryGetReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoryGetReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.HistoryGetReply";
  }
  protected:
  explicit HistoryGetReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
    kOkFieldNumber = 2,
  };
  // bytes v = 1;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // bool ok = 2;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:remote.HistoryGetReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class IndexRangeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.IndexRangeReq) */ {
 public:
  inline IndexRangeReq() : IndexRangeReq(nullptr) {}
  ~IndexRangeReq() override;
  explicit PROTOBUF_CONSTEXPR IndexRangeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexRangeReq(const IndexRangeReq& from);
  IndexRangeReq(IndexRangeReq&& from) noexcept
    : IndexRangeReq() {
    *this = ::std::move(from);
  }

  inline IndexRangeReq& operator=(const IndexRangeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexRangeReq& operator=(IndexRangeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexRangeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexRangeReq* internal_default_instance() {
    return reinterpret_cast<const IndexRangeReq*>(
               &_IndexRangeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(IndexRangeReq& a, IndexRangeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexRangeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexRangeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexRangeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexRangeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexRangeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexRangeReq& from) {
    IndexRangeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexRangeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.IndexRangeReq";
  }
  protected:
  explicit IndexRangeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kKFieldNumber = 3,
    kTxIDFieldNumber = 1,
    kFromTsFieldNumber = 4,
    kToTsFieldNumber = 5,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes k = 3;
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // uint64 txID = 1;
  void clear_txid();
  uint64_t txid() const;
  void set_txid(uint64_t value);
  private:
  uint64_t _internal_txid() const;
  void _internal_set_txid(uint64_t value);
  public:

  // uint64 fromTs = 4;
  void clear_fromts();
  uint64_t fromts() const;
  void set_fromts(uint64_t value);
  private:
  uint64_t _internal_fromts() const;
  void _internal_set_fromts(uint64_t value);
  public:

  // uint64 toTs = 5;
  void clear_tots();
  uint64_t tots() const;
  void set_tots(uint64_t value);
  private:
  uint64_t _internal_tots() const;
  void _internal_set_tots(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:remote.IndexRangeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    uint64_t txid_;
    uint64_t fromts_;
    uint64_t tots_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// -------------------------------------------------------------------

class IndexRangeReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remote.IndexRangeReply) */ {
 public:
  inline IndexRangeReply() : IndexRangeReply(nullptr) {}
  ~IndexRangeReply() override;
  explicit PROTOBUF_CONSTEXPR IndexRangeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexRangeReply(const IndexRangeReply& from);
  IndexRangeReply(IndexRangeReply&& from) noexcept
    : IndexRangeReply() {
    *this = ::std::move(from);
  }

  inline IndexRangeReply& operator=(const IndexRangeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexRangeReply& operator=(IndexRangeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexRangeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexRangeReply* internal_default_instance() {
    return reinterpret_cast<const IndexRangeReply*>(
               &_IndexRangeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(IndexRangeReply& a, IndexRangeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexRangeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexRangeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexRangeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexRangeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexRangeReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexRangeReply& from) {
    IndexRangeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexRangeReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "remote.IndexRangeReply";
  }
  protected:
  explicit IndexRangeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampsFieldNumber = 1,
  };
  // repeated uint64 timestamps = 1;
  int timestamps_size() const;
  private:
  int _internal_timestamps_size() const;
  public:
  void clear_timestamps();
  private:
  uint64_t _internal_timestamps(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_timestamps() const;
  void _internal_add_timestamps(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_timestamps();
  public:
  uint64_t timestamps(int index) const;
  void set_timestamps(int index, uint64_t value);
  void add_timestamps(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      timestamps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_timestamps();

  // @@protoc_insertion_point(class_scope:remote.IndexRangeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > timestamps_;
    mutable std::atomic<int> _timestamps_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_2fkv_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Cursor

// .remote.Op op = 1;
inline void Cursor::clear_op() {
  _impl_.op_ = 0;
}
inline ::remote::Op Cursor::_internal_op() const {
  return static_cast< ::remote::Op >(_impl_.op_);
}
inline ::remote::Op Cursor::op() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.op)
  return _internal_op();
}
inline void Cursor::_internal_set_op(::remote::Op value) {
  
  _impl_.op_ = value;
}
inline void Cursor::set_op(::remote::Op value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:remote.Cursor.op)
}

// string bucketName = 2;
inline void Cursor::clear_bucketname() {
  _impl_.bucketname_.ClearToEmpty();
}
inline const std::string& Cursor::bucketname() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.bucketName)
  return _internal_bucketname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cursor::set_bucketname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bucketname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Cursor.bucketName)
}
inline std::string* Cursor::mutable_bucketname() {
  std::string* _s = _internal_mutable_bucketname();
  // @@protoc_insertion_point(field_mutable:remote.Cursor.bucketName)
  return _s;
}
inline const std::string& Cursor::_internal_bucketname() const {
  return _impl_.bucketname_.Get();
}
inline void Cursor::_internal_set_bucketname(const std::string& value) {
  
  _impl_.bucketname_.Set(value, GetArenaForAllocation());
}
inline std::string* Cursor::_internal_mutable_bucketname() {
  
  return _impl_.bucketname_.Mutable(GetArenaForAllocation());
}
inline std::string* Cursor::release_bucketname() {
  // @@protoc_insertion_point(field_release:remote.Cursor.bucketName)
  return _impl_.bucketname_.Release();
}
inline void Cursor::set_allocated_bucketname(std::string* bucketname) {
  if (bucketname != nullptr) {
    
  } else {
    
  }
  _impl_.bucketname_.SetAllocated(bucketname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bucketname_.IsDefault()) {
    _impl_.bucketname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Cursor.bucketName)
}

// uint32 cursor = 3;
inline void Cursor::clear_cursor() {
  _impl_.cursor_ = 0u;
}
inline uint32_t Cursor::_internal_cursor() const {
  return _impl_.cursor_;
}
inline uint32_t Cursor::cursor() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.cursor)
  return _internal_cursor();
}
inline void Cursor::_internal_set_cursor(uint32_t value) {
  
  _impl_.cursor_ = value;
}
inline void Cursor::set_cursor(uint32_t value) {
  _internal_set_cursor(value);
  // @@protoc_insertion_point(field_set:remote.Cursor.cursor)
}

// bytes k = 4;
inline void Cursor::clear_k() {
  _impl_.k_.ClearToEmpty();
}
inline const std::string& Cursor::k() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cursor::set_k(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Cursor.k)
}
inline std::string* Cursor::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:remote.Cursor.k)
  return _s;
}
inline const std::string& Cursor::_internal_k() const {
  return _impl_.k_.Get();
}
inline void Cursor::_internal_set_k(const std::string& value) {
  
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* Cursor::_internal_mutable_k() {
  
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* Cursor::release_k() {
  // @@protoc_insertion_point(field_release:remote.Cursor.k)
  return _impl_.k_.Release();
}
inline void Cursor::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    
  } else {
    
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Cursor.k)
}

// bytes v = 5;
inline void Cursor::clear_v() {
  _impl_.v_.ClearToEmpty();
}
inline const std::string& Cursor::v() const {
  // @@protoc_insertion_point(field_get:remote.Cursor.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cursor::set_v(ArgT0&& arg0, ArgT... args) {
 
 _impl_.v_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Cursor.v)
}
inline std::string* Cursor::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:remote.Cursor.v)
  return _s;
}
inline const std::string& Cursor::_internal_v() const {
  return _impl_.v_.Get();
}
inline void Cursor::_internal_set_v(const std::string& value) {
  
  _impl_.v_.Set(value, GetArenaForAllocation());
}
inline std::string* Cursor::_internal_mutable_v() {
  
  return _impl_.v_.Mutable(GetArenaForAllocation());
}
inline std::string* Cursor::release_v() {
  // @@protoc_insertion_point(field_release:remote.Cursor.v)
  return _impl_.v_.Release();
}
inline void Cursor::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  _impl_.v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.v_.IsDefault()) {
    _impl_.v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Cursor.v)
}

// -------------------------------------------------------------------

// Pair

// bytes k = 1;
inline void Pair::clear_k() {
  _impl_.k_.ClearToEmpty();
}
inline const std::string& Pair::k() const {
  // @@protoc_insertion_point(field_get:remote.Pair.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pair::set_k(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Pair.k)
}
inline std::string* Pair::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:remote.Pair.k)
  return _s;
}
inline const std::string& Pair::_internal_k() const {
  return _impl_.k_.Get();
}
inline void Pair::_internal_set_k(const std::string& value) {
  
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* Pair::_internal_mutable_k() {
  
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* Pair::release_k() {
  // @@protoc_insertion_point(field_release:remote.Pair.k)
  return _impl_.k_.Release();
}
inline void Pair::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    
  } else {
    
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Pair.k)
}

// bytes v = 2;
inline void Pair::clear_v() {
  _impl_.v_.ClearToEmpty();
}
inline const std::string& Pair::v() const {
  // @@protoc_insertion_point(field_get:remote.Pair.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pair::set_v(ArgT0&& arg0, ArgT... args) {
 
 _impl_.v_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.Pair.v)
}
inline std::string* Pair::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:remote.Pair.v)
  return _s;
}
inline const std::string& Pair::_internal_v() const {
  return _impl_.v_.Get();
}
inline void Pair::_internal_set_v(const std::string& value) {
  
  _impl_.v_.Set(value, GetArenaForAllocation());
}
inline std::string* Pair::_internal_mutable_v() {
  
  return _impl_.v_.Mutable(GetArenaForAllocation());
}
inline std::string* Pair::release_v() {
  // @@protoc_insertion_point(field_release:remote.Pair.v)
  return _impl_.v_.Release();
}
inline void Pair::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  _impl_.v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.v_.IsDefault()) {
    _impl_.v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.Pair.v)
}

// uint32 cursorID = 3;
inline void Pair::clear_cursorid() {
  _impl_.cursorid_ = 0u;
}
inline uint32_t Pair::_internal_cursorid() const {
  return _impl_.cursorid_;
}
inline uint32_t Pair::cursorid() const {
  // @@protoc_insertion_point(field_get:remote.Pair.cursorID)
  return _internal_cursorid();
}
inline void Pair::_internal_set_cursorid(uint32_t value) {
  
  _impl_.cursorid_ = value;
}
inline void Pair::set_cursorid(uint32_t value) {
  _internal_set_cursorid(value);
  // @@protoc_insertion_point(field_set:remote.Pair.cursorID)
}

// uint64 viewID = 4;
inline void Pair::clear_viewid() {
  _impl_.viewid_ = uint64_t{0u};
}
inline uint64_t Pair::_internal_viewid() const {
  return _impl_.viewid_;
}
inline uint64_t Pair::viewid() const {
  // @@protoc_insertion_point(field_get:remote.Pair.viewID)
  return _internal_viewid();
}
inline void Pair::_internal_set_viewid(uint64_t value) {
  
  _impl_.viewid_ = value;
}
inline void Pair::set_viewid(uint64_t value) {
  _internal_set_viewid(value);
  // @@protoc_insertion_point(field_set:remote.Pair.viewID)
}

// uint64 txID = 5;
inline void Pair::clear_txid() {
  _impl_.txid_ = uint64_t{0u};
}
inline uint64_t Pair::_internal_txid() const {
  return _impl_.txid_;
}
inline uint64_t Pair::txid() const {
  // @@protoc_insertion_point(field_get:remote.Pair.txID)
  return _internal_txid();
}
inline void Pair::_internal_set_txid(uint64_t value) {
  
  _impl_.txid_ = value;
}
inline void Pair::set_txid(uint64_t value) {
  _internal_set_txid(value);
  // @@protoc_insertion_point(field_set:remote.Pair.txID)
}

// -------------------------------------------------------------------

// StorageChange

// .types.H256 location = 1;
inline bool StorageChange::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool StorageChange::has_location() const {
  return _internal_has_location();
}
inline const ::types::H256& StorageChange::_internal_location() const {
  const ::types::H256* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& StorageChange::location() const {
  // @@protoc_insertion_point(field_get:remote.StorageChange.location)
  return _internal_location();
}
inline void StorageChange::unsafe_arena_set_allocated_location(
    ::types::H256* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.StorageChange.location)
}
inline ::types::H256* StorageChange::release_location() {
  
  ::types::H256* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* StorageChange::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:remote.StorageChange.location)
  
  ::types::H256* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::types::H256* StorageChange::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::types::H256* StorageChange::mutable_location() {
  ::types::H256* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:remote.StorageChange.location)
  return _msg;
}
inline void StorageChange::set_allocated_location(::types::H256* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location));
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:remote.StorageChange.location)
}

// bytes data = 2;
inline void StorageChange::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& StorageChange::data() const {
  // @@protoc_insertion_point(field_get:remote.StorageChange.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageChange::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.StorageChange.data)
}
inline std::string* StorageChange::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:remote.StorageChange.data)
  return _s;
}
inline const std::string& StorageChange::_internal_data() const {
  return _impl_.data_.Get();
}
inline void StorageChange::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageChange::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageChange::release_data() {
  // @@protoc_insertion_point(field_release:remote.StorageChange.data)
  return _impl_.data_.Release();
}
inline void StorageChange::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.StorageChange.data)
}

// -------------------------------------------------------------------

// AccountChange

// .types.H160 address = 1;
inline bool AccountChange::_internal_has_address() const {
  return this != internal_default_instance() && _impl_.address_ != nullptr;
}
inline bool AccountChange::has_address() const {
  return _internal_has_address();
}
inline const ::types::H160& AccountChange::_internal_address() const {
  const ::types::H160* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(
      ::types::_H160_default_instance_);
}
inline const ::types::H160& AccountChange::address() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.address)
  return _internal_address();
}
inline void AccountChange::unsafe_arena_set_allocated_address(
    ::types::H160* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.AccountChange.address)
}
inline ::types::H160* AccountChange::release_address() {
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H160* AccountChange::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:remote.AccountChange.address)
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::types::H160* AccountChange::_internal_mutable_address() {
  
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArenaForAllocation());
    _impl_.address_ = p;
  }
  return _impl_.address_;
}
inline ::types::H160* AccountChange::mutable_address() {
  ::types::H160* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:remote.AccountChange.address)
  return _msg;
}
inline void AccountChange::set_allocated_address(::types::H160* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address));
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.address_ = address;
  // @@protoc_insertion_point(field_set_allocated:remote.AccountChange.address)
}

// uint64 incarnation = 2;
inline void AccountChange::clear_incarnation() {
  _impl_.incarnation_ = uint64_t{0u};
}
inline uint64_t AccountChange::_internal_incarnation() const {
  return _impl_.incarnation_;
}
inline uint64_t AccountChange::incarnation() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.incarnation)
  return _internal_incarnation();
}
inline void AccountChange::_internal_set_incarnation(uint64_t value) {
  
  _impl_.incarnation_ = value;
}
inline void AccountChange::set_incarnation(uint64_t value) {
  _internal_set_incarnation(value);
  // @@protoc_insertion_point(field_set:remote.AccountChange.incarnation)
}

// .remote.Action action = 3;
inline void AccountChange::clear_action() {
  _impl_.action_ = 0;
}
inline ::remote::Action AccountChange::_internal_action() const {
  return static_cast< ::remote::Action >(_impl_.action_);
}
inline ::remote::Action AccountChange::action() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.action)
  return _internal_action();
}
inline void AccountChange::_internal_set_action(::remote::Action value) {
  
  _impl_.action_ = value;
}
inline void AccountChange::set_action(::remote::Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:remote.AccountChange.action)
}

// bytes data = 4;
inline void AccountChange::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& AccountChange::data() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountChange::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.AccountChange.data)
}
inline std::string* AccountChange::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:remote.AccountChange.data)
  return _s;
}
inline const std::string& AccountChange::_internal_data() const {
  return _impl_.data_.Get();
}
inline void AccountChange::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountChange::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountChange::release_data() {
  // @@protoc_insertion_point(field_release:remote.AccountChange.data)
  return _impl_.data_.Release();
}
inline void AccountChange::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.AccountChange.data)
}

// bytes code = 5;
inline void AccountChange::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& AccountChange::code() const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountChange::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.AccountChange.code)
}
inline std::string* AccountChange::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:remote.AccountChange.code)
  return _s;
}
inline const std::string& AccountChange::_internal_code() const {
  return _impl_.code_.Get();
}
inline void AccountChange::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountChange::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountChange::release_code() {
  // @@protoc_insertion_point(field_release:remote.AccountChange.code)
  return _impl_.code_.Release();
}
inline void AccountChange::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.AccountChange.code)
}

// repeated .remote.StorageChange storageChanges = 6;
inline int AccountChange::_internal_storagechanges_size() const {
  return _impl_.storagechanges_.size();
}
inline int AccountChange::storagechanges_size() const {
  return _internal_storagechanges_size();
}
inline void AccountChange::clear_storagechanges() {
  _impl_.storagechanges_.Clear();
}
inline ::remote::StorageChange* AccountChange::mutable_storagechanges(int index) {
  // @@protoc_insertion_point(field_mutable:remote.AccountChange.storageChanges)
  return _impl_.storagechanges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange >*
AccountChange::mutable_storagechanges() {
  // @@protoc_insertion_point(field_mutable_list:remote.AccountChange.storageChanges)
  return &_impl_.storagechanges_;
}
inline const ::remote::StorageChange& AccountChange::_internal_storagechanges(int index) const {
  return _impl_.storagechanges_.Get(index);
}
inline const ::remote::StorageChange& AccountChange::storagechanges(int index) const {
  // @@protoc_insertion_point(field_get:remote.AccountChange.storageChanges)
  return _internal_storagechanges(index);
}
inline ::remote::StorageChange* AccountChange::_internal_add_storagechanges() {
  return _impl_.storagechanges_.Add();
}
inline ::remote::StorageChange* AccountChange::add_storagechanges() {
  ::remote::StorageChange* _add = _internal_add_storagechanges();
  // @@protoc_insertion_point(field_add:remote.AccountChange.storageChanges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StorageChange >&
AccountChange::storagechanges() const {
  // @@protoc_insertion_point(field_list:remote.AccountChange.storageChanges)
  return _impl_.storagechanges_;
}

// -------------------------------------------------------------------

// StateChangeBatch

// uint64 stateVersionID = 1;
inline void StateChangeBatch::clear_stateversionid() {
  _impl_.stateversionid_ = uint64_t{0u};
}
inline uint64_t StateChangeBatch::_internal_stateversionid() const {
  return _impl_.stateversionid_;
}
inline uint64_t StateChangeBatch::stateversionid() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.stateVersionID)
  return _internal_stateversionid();
}
inline void StateChangeBatch::_internal_set_stateversionid(uint64_t value) {
  
  _impl_.stateversionid_ = value;
}
inline void StateChangeBatch::set_stateversionid(uint64_t value) {
  _internal_set_stateversionid(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeBatch.stateVersionID)
}

// repeated .remote.StateChange changeBatch = 2;
inline int StateChangeBatch::_internal_changebatch_size() const {
  return _impl_.changebatch_.size();
}
inline int StateChangeBatch::changebatch_size() const {
  return _internal_changebatch_size();
}
inline void StateChangeBatch::clear_changebatch() {
  _impl_.changebatch_.Clear();
}
inline ::remote::StateChange* StateChangeBatch::mutable_changebatch(int index) {
  // @@protoc_insertion_point(field_mutable:remote.StateChangeBatch.changeBatch)
  return _impl_.changebatch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange >*
StateChangeBatch::mutable_changebatch() {
  // @@protoc_insertion_point(field_mutable_list:remote.StateChangeBatch.changeBatch)
  return &_impl_.changebatch_;
}
inline const ::remote::StateChange& StateChangeBatch::_internal_changebatch(int index) const {
  return _impl_.changebatch_.Get(index);
}
inline const ::remote::StateChange& StateChangeBatch::changebatch(int index) const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.changeBatch)
  return _internal_changebatch(index);
}
inline ::remote::StateChange* StateChangeBatch::_internal_add_changebatch() {
  return _impl_.changebatch_.Add();
}
inline ::remote::StateChange* StateChangeBatch::add_changebatch() {
  ::remote::StateChange* _add = _internal_add_changebatch();
  // @@protoc_insertion_point(field_add:remote.StateChangeBatch.changeBatch)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::StateChange >&
StateChangeBatch::changebatch() const {
  // @@protoc_insertion_point(field_list:remote.StateChangeBatch.changeBatch)
  return _impl_.changebatch_;
}

// uint64 pendingBlockBaseFee = 3;
inline void StateChangeBatch::clear_pendingblockbasefee() {
  _impl_.pendingblockbasefee_ = uint64_t{0u};
}
inline uint64_t StateChangeBatch::_internal_pendingblockbasefee() const {
  return _impl_.pendingblockbasefee_;
}
inline uint64_t StateChangeBatch::pendingblockbasefee() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.pendingBlockBaseFee)
  return _internal_pendingblockbasefee();
}
inline void StateChangeBatch::_internal_set_pendingblockbasefee(uint64_t value) {
  
  _impl_.pendingblockbasefee_ = value;
}
inline void StateChangeBatch::set_pendingblockbasefee(uint64_t value) {
  _internal_set_pendingblockbasefee(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeBatch.pendingBlockBaseFee)
}

// uint64 blockGasLimit = 4;
inline void StateChangeBatch::clear_blockgaslimit() {
  _impl_.blockgaslimit_ = uint64_t{0u};
}
inline uint64_t StateChangeBatch::_internal_blockgaslimit() const {
  return _impl_.blockgaslimit_;
}
inline uint64_t StateChangeBatch::blockgaslimit() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeBatch.blockGasLimit)
  return _internal_blockgaslimit();
}
inline void StateChangeBatch::_internal_set_blockgaslimit(uint64_t value) {
  
  _impl_.blockgaslimit_ = value;
}
inline void StateChangeBatch::set_blockgaslimit(uint64_t value) {
  _internal_set_blockgaslimit(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeBatch.blockGasLimit)
}

// -------------------------------------------------------------------

// StateChange

// .remote.Direction direction = 1;
inline void StateChange::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::remote::Direction StateChange::_internal_direction() const {
  return static_cast< ::remote::Direction >(_impl_.direction_);
}
inline ::remote::Direction StateChange::direction() const {
  // @@protoc_insertion_point(field_get:remote.StateChange.direction)
  return _internal_direction();
}
inline void StateChange::_internal_set_direction(::remote::Direction value) {
  
  _impl_.direction_ = value;
}
inline void StateChange::set_direction(::remote::Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:remote.StateChange.direction)
}

// uint64 blockHeight = 2;
inline void StateChange::clear_blockheight() {
  _impl_.blockheight_ = uint64_t{0u};
}
inline uint64_t StateChange::_internal_blockheight() const {
  return _impl_.blockheight_;
}
inline uint64_t StateChange::blockheight() const {
  // @@protoc_insertion_point(field_get:remote.StateChange.blockHeight)
  return _internal_blockheight();
}
inline void StateChange::_internal_set_blockheight(uint64_t value) {
  
  _impl_.blockheight_ = value;
}
inline void StateChange::set_blockheight(uint64_t value) {
  _internal_set_blockheight(value);
  // @@protoc_insertion_point(field_set:remote.StateChange.blockHeight)
}

// .types.H256 blockHash = 3;
inline bool StateChange::_internal_has_blockhash() const {
  return this != internal_default_instance() && _impl_.blockhash_ != nullptr;
}
inline bool StateChange::has_blockhash() const {
  return _internal_has_blockhash();
}
inline const ::types::H256& StateChange::_internal_blockhash() const {
  const ::types::H256* p = _impl_.blockhash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& StateChange::blockhash() const {
  // @@protoc_insertion_point(field_get:remote.StateChange.blockHash)
  return _internal_blockhash();
}
inline void StateChange::unsafe_arena_set_allocated_blockhash(
    ::types::H256* blockhash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blockhash_);
  }
  _impl_.blockhash_ = blockhash;
  if (blockhash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:remote.StateChange.blockHash)
}
inline ::types::H256* StateChange::release_blockhash() {
  
  ::types::H256* temp = _impl_.blockhash_;
  _impl_.blockhash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* StateChange::unsafe_arena_release_blockhash() {
  // @@protoc_insertion_point(field_release:remote.StateChange.blockHash)
  
  ::types::H256* temp = _impl_.blockhash_;
  _impl_.blockhash_ = nullptr;
  return temp;
}
inline ::types::H256* StateChange::_internal_mutable_blockhash() {
  
  if (_impl_.blockhash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.blockhash_ = p;
  }
  return _impl_.blockhash_;
}
inline ::types::H256* StateChange::mutable_blockhash() {
  ::types::H256* _msg = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:remote.StateChange.blockHash)
  return _msg;
}
inline void StateChange::set_allocated_blockhash(::types::H256* blockhash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blockhash_);
  }
  if (blockhash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blockhash));
    if (message_arena != submessage_arena) {
      blockhash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blockhash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blockhash_ = blockhash;
  // @@protoc_insertion_point(field_set_allocated:remote.StateChange.blockHash)
}

// repeated .remote.AccountChange changes = 4;
inline int StateChange::_internal_changes_size() const {
  return _impl_.changes_.size();
}
inline int StateChange::changes_size() const {
  return _internal_changes_size();
}
inline void StateChange::clear_changes() {
  _impl_.changes_.Clear();
}
inline ::remote::AccountChange* StateChange::mutable_changes(int index) {
  // @@protoc_insertion_point(field_mutable:remote.StateChange.changes)
  return _impl_.changes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange >*
StateChange::mutable_changes() {
  // @@protoc_insertion_point(field_mutable_list:remote.StateChange.changes)
  return &_impl_.changes_;
}
inline const ::remote::AccountChange& StateChange::_internal_changes(int index) const {
  return _impl_.changes_.Get(index);
}
inline const ::remote::AccountChange& StateChange::changes(int index) const {
  // @@protoc_insertion_point(field_get:remote.StateChange.changes)
  return _internal_changes(index);
}
inline ::remote::AccountChange* StateChange::_internal_add_changes() {
  return _impl_.changes_.Add();
}
inline ::remote::AccountChange* StateChange::add_changes() {
  ::remote::AccountChange* _add = _internal_add_changes();
  // @@protoc_insertion_point(field_add:remote.StateChange.changes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remote::AccountChange >&
StateChange::changes() const {
  // @@protoc_insertion_point(field_list:remote.StateChange.changes)
  return _impl_.changes_;
}

// repeated bytes txs = 5;
inline int StateChange::_internal_txs_size() const {
  return _impl_.txs_.size();
}
inline int StateChange::txs_size() const {
  return _internal_txs_size();
}
inline void StateChange::clear_txs() {
  _impl_.txs_.Clear();
}
inline std::string* StateChange::add_txs() {
  std::string* _s = _internal_add_txs();
  // @@protoc_insertion_point(field_add_mutable:remote.StateChange.txs)
  return _s;
}
inline const std::string& StateChange::_internal_txs(int index) const {
  return _impl_.txs_.Get(index);
}
inline const std::string& StateChange::txs(int index) const {
  // @@protoc_insertion_point(field_get:remote.StateChange.txs)
  return _internal_txs(index);
}
inline std::string* StateChange::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:remote.StateChange.txs)
  return _impl_.txs_.Mutable(index);
}
inline void StateChange::set_txs(int index, const std::string& value) {
  _impl_.txs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:remote.StateChange.txs)
}
inline void StateChange::set_txs(int index, std::string&& value) {
  _impl_.txs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:remote.StateChange.txs)
}
inline void StateChange::set_txs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.txs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:remote.StateChange.txs)
}
inline void StateChange::set_txs(int index, const void* value, size_t size) {
  _impl_.txs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:remote.StateChange.txs)
}
inline std::string* StateChange::_internal_add_txs() {
  return _impl_.txs_.Add();
}
inline void StateChange::add_txs(const std::string& value) {
  _impl_.txs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:remote.StateChange.txs)
}
inline void StateChange::add_txs(std::string&& value) {
  _impl_.txs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:remote.StateChange.txs)
}
inline void StateChange::add_txs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.txs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:remote.StateChange.txs)
}
inline void StateChange::add_txs(const void* value, size_t size) {
  _impl_.txs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:remote.StateChange.txs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StateChange::txs() const {
  // @@protoc_insertion_point(field_list:remote.StateChange.txs)
  return _impl_.txs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StateChange::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:remote.StateChange.txs)
  return &_impl_.txs_;
}

// -------------------------------------------------------------------

// StateChangeRequest

// bool withStorage = 1;
inline void StateChangeRequest::clear_withstorage() {
  _impl_.withstorage_ = false;
}
inline bool StateChangeRequest::_internal_withstorage() const {
  return _impl_.withstorage_;
}
inline bool StateChangeRequest::withstorage() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeRequest.withStorage)
  return _internal_withstorage();
}
inline void StateChangeRequest::_internal_set_withstorage(bool value) {
  
  _impl_.withstorage_ = value;
}
inline void StateChangeRequest::set_withstorage(bool value) {
  _internal_set_withstorage(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeRequest.withStorage)
}

// bool withTransactions = 2;
inline void StateChangeRequest::clear_withtransactions() {
  _impl_.withtransactions_ = false;
}
inline bool StateChangeRequest::_internal_withtransactions() const {
  return _impl_.withtransactions_;
}
inline bool StateChangeRequest::withtransactions() const {
  // @@protoc_insertion_point(field_get:remote.StateChangeRequest.withTransactions)
  return _internal_withtransactions();
}
inline void StateChangeRequest::_internal_set_withtransactions(bool value) {
  
  _impl_.withtransactions_ = value;
}
inline void StateChangeRequest::set_withtransactions(bool value) {
  _internal_set_withtransactions(value);
  // @@protoc_insertion_point(field_set:remote.StateChangeRequest.withTransactions)
}

// -------------------------------------------------------------------

// SnapshotsRequest

// -------------------------------------------------------------------

// SnapshotsReply

// repeated string files = 1;
inline int SnapshotsReply::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int SnapshotsReply::files_size() const {
  return _internal_files_size();
}
inline void SnapshotsReply::clear_files() {
  _impl_.files_.Clear();
}
inline std::string* SnapshotsReply::add_files() {
  std::string* _s = _internal_add_files();
  // @@protoc_insertion_point(field_add_mutable:remote.SnapshotsReply.files)
  return _s;
}
inline const std::string& SnapshotsReply::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const std::string& SnapshotsReply::files(int index) const {
  // @@protoc_insertion_point(field_get:remote.SnapshotsReply.files)
  return _internal_files(index);
}
inline std::string* SnapshotsReply::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:remote.SnapshotsReply.files)
  return _impl_.files_.Mutable(index);
}
inline void SnapshotsReply::set_files(int index, const std::string& value) {
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:remote.SnapshotsReply.files)
}
inline void SnapshotsReply::set_files(int index, std::string&& value) {
  _impl_.files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:remote.SnapshotsReply.files)
}
inline void SnapshotsReply::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:remote.SnapshotsReply.files)
}
inline void SnapshotsReply::set_files(int index, const char* value, size_t size) {
  _impl_.files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:remote.SnapshotsReply.files)
}
inline std::string* SnapshotsReply::_internal_add_files() {
  return _impl_.files_.Add();
}
inline void SnapshotsReply::add_files(const std::string& value) {
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:remote.SnapshotsReply.files)
}
inline void SnapshotsReply::add_files(std::string&& value) {
  _impl_.files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:remote.SnapshotsReply.files)
}
inline void SnapshotsReply::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:remote.SnapshotsReply.files)
}
inline void SnapshotsReply::add_files(const char* value, size_t size) {
  _impl_.files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:remote.SnapshotsReply.files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SnapshotsReply::files() const {
  // @@protoc_insertion_point(field_list:remote.SnapshotsReply.files)
  return _impl_.files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SnapshotsReply::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:remote.SnapshotsReply.files)
  return &_impl_.files_;
}

// -------------------------------------------------------------------

// HistoryGetReq

// uint64 txID = 1;
inline void HistoryGetReq::clear_txid() {
  _impl_.txid_ = uint64_t{0u};
}
inline uint64_t HistoryGetReq::_internal_txid() const {
  return _impl_.txid_;
}
inline uint64_t HistoryGetReq::txid() const {
  // @@protoc_insertion_point(field_get:remote.HistoryGetReq.txID)
  return _internal_txid();
}
inline void HistoryGetReq::_internal_set_txid(uint64_t value) {
  
  _impl_.txid_ = value;
}
inline void HistoryGetReq::set_txid(uint64_t value) {
  _internal_set_txid(value);
  // @@protoc_insertion_point(field_set:remote.HistoryGetReq.txID)
}

// string name = 2;
inline void HistoryGetReq::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HistoryGetReq::name() const {
  // @@protoc_insertion_point(field_get:remote.HistoryGetReq.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistoryGetReq::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.HistoryGetReq.name)
}
inline std::string* HistoryGetReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:remote.HistoryGetReq.name)
  return _s;
}
inline const std::string& HistoryGetReq::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HistoryGetReq::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HistoryGetReq::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HistoryGetReq::release_name() {
  // @@protoc_insertion_point(field_release:remote.HistoryGetReq.name)
  return _impl_.name_.Release();
}
inline void HistoryGetReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.HistoryGetReq.name)
}

// bytes k = 3;
inline void HistoryGetReq::clear_k() {
  _impl_.k_.ClearToEmpty();
}
inline const std::string& HistoryGetReq::k() const {
  // @@protoc_insertion_point(field_get:remote.HistoryGetReq.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistoryGetReq::set_k(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.HistoryGetReq.k)
}
inline std::string* HistoryGetReq::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:remote.HistoryGetReq.k)
  return _s;
}
inline const std::string& HistoryGetReq::_internal_k() const {
  return _impl_.k_.Get();
}
inline void HistoryGetReq::_internal_set_k(const std::string& value) {
  
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* HistoryGetReq::_internal_mutable_k() {
  
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* HistoryGetReq::release_k() {
  // @@protoc_insertion_point(field_release:remote.HistoryGetReq.k)
  return _impl_.k_.Release();
}
inline void HistoryGetReq::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    
  } else {
    
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.HistoryGetReq.k)
}

// uint64 ts = 4;
inline void HistoryGetReq::clear_ts() {
  _impl_.ts_ = uint64_t{0u};
}
inline uint64_t HistoryGetReq::_internal_ts() const {
  return _impl_.ts_;
}
inline uint64_t HistoryGetReq::ts() const {
  // @@protoc_insertion_point(field_get:remote.HistoryGetReq.ts)
  return _internal_ts();
}
inline void HistoryGetReq::_internal_set_ts(uint64_t value) {
  
  _impl_.ts_ = value;
}
inline void HistoryGetReq::set_ts(uint64_t value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:remote.HistoryGetReq.ts)
}

// -------------------------------------------------------------------

// HistoryGetReply

// bytes v = 1;
inline void HistoryGetReply::clear_v() {
  _impl_.v_.ClearToEmpty();
}
inline const std::string& HistoryGetReply::v() const {
  // @@protoc_insertion_point(field_get:remote.HistoryGetReply.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistoryGetReply::set_v(ArgT0&& arg0, ArgT... args) {
 
 _impl_.v_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.HistoryGetReply.v)
}
inline std::string* HistoryGetReply::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:remote.HistoryGetReply.v)
  return _s;
}
inline const std::string& HistoryGetReply::_internal_v() const {
  return _impl_.v_.Get();
}
inline void HistoryGetReply::_internal_set_v(const std::string& value) {
  
  _impl_.v_.Set(value, GetArenaForAllocation());
}
inline std::string* HistoryGetReply::_internal_mutable_v() {
  
  return _impl_.v_.Mutable(GetArenaForAllocation());
}
inline std::string* HistoryGetReply::release_v() {
  // @@protoc_insertion_point(field_release:remote.HistoryGetReply.v)
  return _impl_.v_.Release();
}
inline void HistoryGetReply::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  _impl_.v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.v_.IsDefault()) {
    _impl_.v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.HistoryGetReply.v)
}

// bool ok = 2;
inline void HistoryGetReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool HistoryGetReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool HistoryGetReply::ok() const {
  // @@protoc_insertion_point(field_get:remote.HistoryGetReply.ok)
  return _internal_ok();
}
inline void HistoryGetReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void HistoryGetReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:remote.HistoryGetReply.ok)
}

// -------------------------------------------------------------------

// IndexRangeReq

// uint64 txID = 1;
inline void IndexRangeReq::clear_txid() {
  _impl_.txid_ = uint64_t{0u};
}
inline uint64_t IndexRangeReq::_internal_txid() const {
  return _impl_.txid_;
}
inline uint64_t IndexRangeReq::txid() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.txID)
  return _internal_txid();
}
inline void IndexRangeReq::_internal_set_txid(uint64_t value) {
  
  _impl_.txid_ = value;
}
inline void IndexRangeReq::set_txid(uint64_t value) {
  _internal_set_txid(value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.txID)
}

// string name = 2;
inline void IndexRangeReq::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& IndexRangeReq::name() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexRangeReq::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.name)
}
inline std::string* IndexRangeReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:remote.IndexRangeReq.name)
  return _s;
}
inline const std::string& IndexRangeReq::_internal_name() const {
  return _impl_.name_.Get();
}
inline void IndexRangeReq::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* IndexRangeReq::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* IndexRangeReq::release_name() {
  // @@protoc_insertion_point(field_release:remote.IndexRangeReq.name)
  return _impl_.name_.Release();
}
inline void IndexRangeReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.IndexRangeReq.name)
}

// bytes k = 3;
inline void IndexRangeReq::clear_k() {
  _impl_.k_.ClearToEmpty();
}
inline const std::string& IndexRangeReq::k() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexRangeReq::set_k(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.k)
}
inline std::string* IndexRangeReq::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:remote.IndexRangeReq.k)
  return _s;
}
inline const std::string& IndexRangeReq::_internal_k() const {
  return _impl_.k_.Get();
}
inline void IndexRangeReq::_internal_set_k(const std::string& value) {
  
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* IndexRangeReq::_internal_mutable_k() {
  
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* IndexRangeReq::release_k() {
  // @@protoc_insertion_point(field_release:remote.IndexRangeReq.k)
  return _impl_.k_.Release();
}
inline void IndexRangeReq::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    
  } else {
    
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remote.IndexRangeReq.k)
}

// uint64 fromTs = 4;
inline void IndexRangeReq::clear_fromts() {
  _impl_.fromts_ = uint64_t{0u};
}
inline uint64_t IndexRangeReq::_internal_fromts() const {
  return _impl_.fromts_;
}
inline uint64_t IndexRangeReq::fromts() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.fromTs)
  return _internal_fromts();
}
inline void IndexRangeReq::_internal_set_fromts(uint64_t value) {
  
  _impl_.fromts_ = value;
}
inline void IndexRangeReq::set_fromts(uint64_t value) {
  _internal_set_fromts(value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.fromTs)
}

// uint64 toTs = 5;
inline void IndexRangeReq::clear_tots() {
  _impl_.tots_ = uint64_t{0u};
}
inline uint64_t IndexRangeReq::_internal_tots() const {
  return _impl_.tots_;
}
inline uint64_t IndexRangeReq::tots() const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReq.toTs)
  return _internal_tots();
}
inline void IndexRangeReq::_internal_set_tots(uint64_t value) {
  
  _impl_.tots_ = value;
}
inline void IndexRangeReq::set_tots(uint64_t value) {
  _internal_set_tots(value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReq.toTs)
}

// -------------------------------------------------------------------

// IndexRangeReply

// repeated uint64 timestamps = 1;
inline int IndexRangeReply::_internal_timestamps_size() const {
  return _impl_.timestamps_.size();
}
inline int IndexRangeReply::timestamps_size() const {
  return _internal_timestamps_size();
}
inline void IndexRangeReply::clear_timestamps() {
  _impl_.timestamps_.Clear();
}
inline uint64_t IndexRangeReply::_internal_timestamps(int index) const {
  return _impl_.timestamps_.Get(index);
}
inline uint64_t IndexRangeReply::timestamps(int index) const {
  // @@protoc_insertion_point(field_get:remote.IndexRangeReply.timestamps)
  return _internal_timestamps(index);
}
inline void IndexRangeReply::set_timestamps(int index, uint64_t value) {
  _impl_.timestamps_.Set(index, value);
  // @@protoc_insertion_point(field_set:remote.IndexRangeReply.timestamps)
}
inline void IndexRangeReply::_internal_add_timestamps(uint64_t value) {
  _impl_.timestamps_.Add(value);
}
inline void IndexRangeReply::add_timestamps(uint64_t value) {
  _internal_add_timestamps(value);
  // @@protoc_insertion_point(field_add:remote.IndexRangeReply.timestamps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
IndexRangeReply::_internal_timestamps() const {
  return _impl_.timestamps_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
IndexRangeReply::timestamps() const {
  // @@protoc_insertion_point(field_list:remote.IndexRangeReply.timestamps)
  return _internal_timestamps();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
IndexRangeReply::_internal_mutable_timestamps() {
  return &_impl_.timestamps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
IndexRangeReply::mutable_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:remote.IndexRangeReply.timestamps)
  return _internal_mutable_timestamps();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace remote

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::remote::Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::Op>() {
  return ::remote::Op_descriptor();
}
template <> struct is_proto_enum< ::remote::Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::Action>() {
  return ::remote::Action_descriptor();
}
template <> struct is_proto_enum< ::remote::Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote::Direction>() {
  return ::remote::Direction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_remote_2fkv_2eproto
