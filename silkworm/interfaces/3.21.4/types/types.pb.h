// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_types_2ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_types_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_types_2ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_types_2ftypes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_types_2ftypes_2eproto;
namespace types {
class ExecutionPayload;
struct ExecutionPayloadDefaultTypeInternal;
extern ExecutionPayloadDefaultTypeInternal _ExecutionPayload_default_instance_;
class ExecutionPayloadV2;
struct ExecutionPayloadV2DefaultTypeInternal;
extern ExecutionPayloadV2DefaultTypeInternal _ExecutionPayloadV2_default_instance_;
class H1024;
struct H1024DefaultTypeInternal;
extern H1024DefaultTypeInternal _H1024_default_instance_;
class H128;
struct H128DefaultTypeInternal;
extern H128DefaultTypeInternal _H128_default_instance_;
class H160;
struct H160DefaultTypeInternal;
extern H160DefaultTypeInternal _H160_default_instance_;
class H2048;
struct H2048DefaultTypeInternal;
extern H2048DefaultTypeInternal _H2048_default_instance_;
class H256;
struct H256DefaultTypeInternal;
extern H256DefaultTypeInternal _H256_default_instance_;
class H512;
struct H512DefaultTypeInternal;
extern H512DefaultTypeInternal _H512_default_instance_;
class NodeInfoPorts;
struct NodeInfoPortsDefaultTypeInternal;
extern NodeInfoPortsDefaultTypeInternal _NodeInfoPorts_default_instance_;
class NodeInfoReply;
struct NodeInfoReplyDefaultTypeInternal;
extern NodeInfoReplyDefaultTypeInternal _NodeInfoReply_default_instance_;
class PeerInfo;
struct PeerInfoDefaultTypeInternal;
extern PeerInfoDefaultTypeInternal _PeerInfo_default_instance_;
class VersionReply;
struct VersionReplyDefaultTypeInternal;
extern VersionReplyDefaultTypeInternal _VersionReply_default_instance_;
class Withdrawal;
struct WithdrawalDefaultTypeInternal;
extern WithdrawalDefaultTypeInternal _Withdrawal_default_instance_;
}  // namespace types
PROTOBUF_NAMESPACE_OPEN
template<> ::types::ExecutionPayload* Arena::CreateMaybeMessage<::types::ExecutionPayload>(Arena*);
template<> ::types::ExecutionPayloadV2* Arena::CreateMaybeMessage<::types::ExecutionPayloadV2>(Arena*);
template<> ::types::H1024* Arena::CreateMaybeMessage<::types::H1024>(Arena*);
template<> ::types::H128* Arena::CreateMaybeMessage<::types::H128>(Arena*);
template<> ::types::H160* Arena::CreateMaybeMessage<::types::H160>(Arena*);
template<> ::types::H2048* Arena::CreateMaybeMessage<::types::H2048>(Arena*);
template<> ::types::H256* Arena::CreateMaybeMessage<::types::H256>(Arena*);
template<> ::types::H512* Arena::CreateMaybeMessage<::types::H512>(Arena*);
template<> ::types::NodeInfoPorts* Arena::CreateMaybeMessage<::types::NodeInfoPorts>(Arena*);
template<> ::types::NodeInfoReply* Arena::CreateMaybeMessage<::types::NodeInfoReply>(Arena*);
template<> ::types::PeerInfo* Arena::CreateMaybeMessage<::types::PeerInfo>(Arena*);
template<> ::types::VersionReply* Arena::CreateMaybeMessage<::types::VersionReply>(Arena*);
template<> ::types::Withdrawal* Arena::CreateMaybeMessage<::types::Withdrawal>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace types {

// ===================================================================

class H128 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H128) */ {
 public:
  inline H128() : H128(nullptr) {}
  ~H128() override;
  explicit PROTOBUF_CONSTEXPR H128(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  H128(const H128& from);
  H128(H128&& from) noexcept
    : H128() {
    *this = ::std::move(from);
  }

  inline H128& operator=(const H128& from) {
    CopyFrom(from);
    return *this;
  }
  inline H128& operator=(H128&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H128& default_instance() {
    return *internal_default_instance();
  }
  static inline const H128* internal_default_instance() {
    return reinterpret_cast<const H128*>(
               &_H128_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(H128& a, H128& b) {
    a.Swap(&b);
  }
  inline void Swap(H128* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H128* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H128* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<H128>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const H128& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const H128& from) {
    H128::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H128* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H128";
  }
  protected:
  explicit H128(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // uint64 hi = 1;
  void clear_hi();
  uint64_t hi() const;
  void set_hi(uint64_t value);
  private:
  uint64_t _internal_hi() const;
  void _internal_set_hi(uint64_t value);
  public:

  // uint64 lo = 2;
  void clear_lo();
  uint64_t lo() const;
  void set_lo(uint64_t value);
  private:
  uint64_t _internal_lo() const;
  void _internal_set_lo(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.H128)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hi_;
    uint64_t lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H160 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H160) */ {
 public:
  inline H160() : H160(nullptr) {}
  ~H160() override;
  explicit PROTOBUF_CONSTEXPR H160(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  H160(const H160& from);
  H160(H160&& from) noexcept
    : H160() {
    *this = ::std::move(from);
  }

  inline H160& operator=(const H160& from) {
    CopyFrom(from);
    return *this;
  }
  inline H160& operator=(H160&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H160& default_instance() {
    return *internal_default_instance();
  }
  static inline const H160* internal_default_instance() {
    return reinterpret_cast<const H160*>(
               &_H160_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(H160& a, H160& b) {
    a.Swap(&b);
  }
  inline void Swap(H160* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H160* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H160* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<H160>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const H160& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const H160& from) {
    H160::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H160* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H160";
  }
  protected:
  explicit H160(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H128 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H128& hi() const;
  PROTOBUF_NODISCARD ::types::H128* release_hi();
  ::types::H128* mutable_hi();
  void set_allocated_hi(::types::H128* hi);
  private:
  const ::types::H128& _internal_hi() const;
  ::types::H128* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H128* hi);
  ::types::H128* unsafe_arena_release_hi();

  // uint32 lo = 2;
  void clear_lo();
  uint32_t lo() const;
  void set_lo(uint32_t value);
  private:
  uint32_t _internal_lo() const;
  void _internal_set_lo(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.H160)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H128* hi_;
    uint32_t lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H256 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H256) */ {
 public:
  inline H256() : H256(nullptr) {}
  ~H256() override;
  explicit PROTOBUF_CONSTEXPR H256(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  H256(const H256& from);
  H256(H256&& from) noexcept
    : H256() {
    *this = ::std::move(from);
  }

  inline H256& operator=(const H256& from) {
    CopyFrom(from);
    return *this;
  }
  inline H256& operator=(H256&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H256& default_instance() {
    return *internal_default_instance();
  }
  static inline const H256* internal_default_instance() {
    return reinterpret_cast<const H256*>(
               &_H256_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(H256& a, H256& b) {
    a.Swap(&b);
  }
  inline void Swap(H256* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H256* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H256* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<H256>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const H256& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const H256& from) {
    H256::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H256* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H256";
  }
  protected:
  explicit H256(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H128 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H128& hi() const;
  PROTOBUF_NODISCARD ::types::H128* release_hi();
  ::types::H128* mutable_hi();
  void set_allocated_hi(::types::H128* hi);
  private:
  const ::types::H128& _internal_hi() const;
  ::types::H128* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H128* hi);
  ::types::H128* unsafe_arena_release_hi();

  // .types.H128 lo = 2;
  bool has_lo() const;
  private:
  bool _internal_has_lo() const;
  public:
  void clear_lo();
  const ::types::H128& lo() const;
  PROTOBUF_NODISCARD ::types::H128* release_lo();
  ::types::H128* mutable_lo();
  void set_allocated_lo(::types::H128* lo);
  private:
  const ::types::H128& _internal_lo() const;
  ::types::H128* _internal_mutable_lo();
  public:
  void unsafe_arena_set_allocated_lo(
      ::types::H128* lo);
  ::types::H128* unsafe_arena_release_lo();

  // @@protoc_insertion_point(class_scope:types.H256)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H128* hi_;
    ::types::H128* lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H512 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H512) */ {
 public:
  inline H512() : H512(nullptr) {}
  ~H512() override;
  explicit PROTOBUF_CONSTEXPR H512(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  H512(const H512& from);
  H512(H512&& from) noexcept
    : H512() {
    *this = ::std::move(from);
  }

  inline H512& operator=(const H512& from) {
    CopyFrom(from);
    return *this;
  }
  inline H512& operator=(H512&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H512& default_instance() {
    return *internal_default_instance();
  }
  static inline const H512* internal_default_instance() {
    return reinterpret_cast<const H512*>(
               &_H512_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(H512& a, H512& b) {
    a.Swap(&b);
  }
  inline void Swap(H512* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H512* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H512* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<H512>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const H512& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const H512& from) {
    H512::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H512* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H512";
  }
  protected:
  explicit H512(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H256 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H256& hi() const;
  PROTOBUF_NODISCARD ::types::H256* release_hi();
  ::types::H256* mutable_hi();
  void set_allocated_hi(::types::H256* hi);
  private:
  const ::types::H256& _internal_hi() const;
  ::types::H256* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H256* hi);
  ::types::H256* unsafe_arena_release_hi();

  // .types.H256 lo = 2;
  bool has_lo() const;
  private:
  bool _internal_has_lo() const;
  public:
  void clear_lo();
  const ::types::H256& lo() const;
  PROTOBUF_NODISCARD ::types::H256* release_lo();
  ::types::H256* mutable_lo();
  void set_allocated_lo(::types::H256* lo);
  private:
  const ::types::H256& _internal_lo() const;
  ::types::H256* _internal_mutable_lo();
  public:
  void unsafe_arena_set_allocated_lo(
      ::types::H256* lo);
  ::types::H256* unsafe_arena_release_lo();

  // @@protoc_insertion_point(class_scope:types.H512)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H256* hi_;
    ::types::H256* lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H1024 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H1024) */ {
 public:
  inline H1024() : H1024(nullptr) {}
  ~H1024() override;
  explicit PROTOBUF_CONSTEXPR H1024(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  H1024(const H1024& from);
  H1024(H1024&& from) noexcept
    : H1024() {
    *this = ::std::move(from);
  }

  inline H1024& operator=(const H1024& from) {
    CopyFrom(from);
    return *this;
  }
  inline H1024& operator=(H1024&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H1024& default_instance() {
    return *internal_default_instance();
  }
  static inline const H1024* internal_default_instance() {
    return reinterpret_cast<const H1024*>(
               &_H1024_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(H1024& a, H1024& b) {
    a.Swap(&b);
  }
  inline void Swap(H1024* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H1024* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H1024* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<H1024>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const H1024& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const H1024& from) {
    H1024::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H1024* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H1024";
  }
  protected:
  explicit H1024(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H512 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H512& hi() const;
  PROTOBUF_NODISCARD ::types::H512* release_hi();
  ::types::H512* mutable_hi();
  void set_allocated_hi(::types::H512* hi);
  private:
  const ::types::H512& _internal_hi() const;
  ::types::H512* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H512* hi);
  ::types::H512* unsafe_arena_release_hi();

  // .types.H512 lo = 2;
  bool has_lo() const;
  private:
  bool _internal_has_lo() const;
  public:
  void clear_lo();
  const ::types::H512& lo() const;
  PROTOBUF_NODISCARD ::types::H512* release_lo();
  ::types::H512* mutable_lo();
  void set_allocated_lo(::types::H512* lo);
  private:
  const ::types::H512& _internal_lo() const;
  ::types::H512* _internal_mutable_lo();
  public:
  void unsafe_arena_set_allocated_lo(
      ::types::H512* lo);
  ::types::H512* unsafe_arena_release_lo();

  // @@protoc_insertion_point(class_scope:types.H1024)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H512* hi_;
    ::types::H512* lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class H2048 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.H2048) */ {
 public:
  inline H2048() : H2048(nullptr) {}
  ~H2048() override;
  explicit PROTOBUF_CONSTEXPR H2048(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  H2048(const H2048& from);
  H2048(H2048&& from) noexcept
    : H2048() {
    *this = ::std::move(from);
  }

  inline H2048& operator=(const H2048& from) {
    CopyFrom(from);
    return *this;
  }
  inline H2048& operator=(H2048&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const H2048& default_instance() {
    return *internal_default_instance();
  }
  static inline const H2048* internal_default_instance() {
    return reinterpret_cast<const H2048*>(
               &_H2048_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(H2048& a, H2048& b) {
    a.Swap(&b);
  }
  inline void Swap(H2048* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(H2048* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  H2048* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<H2048>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const H2048& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const H2048& from) {
    H2048::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(H2048* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.H2048";
  }
  protected:
  explicit H2048(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // .types.H1024 hi = 1;
  bool has_hi() const;
  private:
  bool _internal_has_hi() const;
  public:
  void clear_hi();
  const ::types::H1024& hi() const;
  PROTOBUF_NODISCARD ::types::H1024* release_hi();
  ::types::H1024* mutable_hi();
  void set_allocated_hi(::types::H1024* hi);
  private:
  const ::types::H1024& _internal_hi() const;
  ::types::H1024* _internal_mutable_hi();
  public:
  void unsafe_arena_set_allocated_hi(
      ::types::H1024* hi);
  ::types::H1024* unsafe_arena_release_hi();

  // .types.H1024 lo = 2;
  bool has_lo() const;
  private:
  bool _internal_has_lo() const;
  public:
  void clear_lo();
  const ::types::H1024& lo() const;
  PROTOBUF_NODISCARD ::types::H1024* release_lo();
  ::types::H1024* mutable_lo();
  void set_allocated_lo(::types::H1024* lo);
  private:
  const ::types::H1024& _internal_lo() const;
  ::types::H1024* _internal_mutable_lo();
  public:
  void unsafe_arena_set_allocated_lo(
      ::types::H1024* lo);
  ::types::H1024* unsafe_arena_release_lo();

  // @@protoc_insertion_point(class_scope:types.H2048)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H1024* hi_;
    ::types::H1024* lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class VersionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.VersionReply) */ {
 public:
  inline VersionReply() : VersionReply(nullptr) {}
  ~VersionReply() override;
  explicit PROTOBUF_CONSTEXPR VersionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionReply(const VersionReply& from);
  VersionReply(VersionReply&& from) noexcept
    : VersionReply() {
    *this = ::std::move(from);
  }

  inline VersionReply& operator=(const VersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionReply& operator=(VersionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionReply* internal_default_instance() {
    return reinterpret_cast<const VersionReply*>(
               &_VersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VersionReply& a, VersionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VersionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VersionReply& from) {
    VersionReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.VersionReply";
  }
  protected:
  explicit VersionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
    kPatchFieldNumber = 3,
  };
  // uint32 major = 1;
  void clear_major();
  uint32_t major() const;
  void set_major(uint32_t value);
  private:
  uint32_t _internal_major() const;
  void _internal_set_major(uint32_t value);
  public:

  // uint32 minor = 2;
  void clear_minor();
  uint32_t minor() const;
  void set_minor(uint32_t value);
  private:
  uint32_t _internal_minor() const;
  void _internal_set_minor(uint32_t value);
  public:

  // uint32 patch = 3;
  void clear_patch();
  uint32_t patch() const;
  void set_patch(uint32_t value);
  private:
  uint32_t _internal_patch() const;
  void _internal_set_patch(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.VersionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t major_;
    uint32_t minor_;
    uint32_t patch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ExecutionPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.ExecutionPayload) */ {
 public:
  inline ExecutionPayload() : ExecutionPayload(nullptr) {}
  ~ExecutionPayload() override;
  explicit PROTOBUF_CONSTEXPR ExecutionPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionPayload(const ExecutionPayload& from);
  ExecutionPayload(ExecutionPayload&& from) noexcept
    : ExecutionPayload() {
    *this = ::std::move(from);
  }

  inline ExecutionPayload& operator=(const ExecutionPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionPayload& operator=(ExecutionPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionPayload* internal_default_instance() {
    return reinterpret_cast<const ExecutionPayload*>(
               &_ExecutionPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ExecutionPayload& a, ExecutionPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecutionPayload& from) {
    ExecutionPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.ExecutionPayload";
  }
  protected:
  explicit ExecutionPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 14,
    kExtraDataFieldNumber = 11,
    kParentHashFieldNumber = 1,
    kCoinbaseFieldNumber = 2,
    kStateRootFieldNumber = 3,
    kReceiptRootFieldNumber = 4,
    kLogsBloomFieldNumber = 5,
    kPrevRandaoFieldNumber = 6,
    kBaseFeePerGasFieldNumber = 12,
    kBlockHashFieldNumber = 13,
    kBlockNumberFieldNumber = 7,
    kGasLimitFieldNumber = 8,
    kGasUsedFieldNumber = 9,
    kTimestampFieldNumber = 10,
  };
  // repeated bytes transactions = 14;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  const std::string& transactions(int index) const;
  std::string* mutable_transactions(int index);
  void set_transactions(int index, const std::string& value);
  void set_transactions(int index, std::string&& value);
  void set_transactions(int index, const char* value);
  void set_transactions(int index, const void* value, size_t size);
  std::string* add_transactions();
  void add_transactions(const std::string& value);
  void add_transactions(std::string&& value);
  void add_transactions(const char* value);
  void add_transactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transactions();
  private:
  const std::string& _internal_transactions(int index) const;
  std::string* _internal_add_transactions();
  public:

  // bytes extraData = 11;
  void clear_extradata();
  const std::string& extradata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extradata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extradata();
  PROTOBUF_NODISCARD std::string* release_extradata();
  void set_allocated_extradata(std::string* extradata);
  private:
  const std::string& _internal_extradata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extradata(const std::string& value);
  std::string* _internal_mutable_extradata();
  public:

  // .types.H256 parentHash = 1;
  bool has_parenthash() const;
  private:
  bool _internal_has_parenthash() const;
  public:
  void clear_parenthash();
  const ::types::H256& parenthash() const;
  PROTOBUF_NODISCARD ::types::H256* release_parenthash();
  ::types::H256* mutable_parenthash();
  void set_allocated_parenthash(::types::H256* parenthash);
  private:
  const ::types::H256& _internal_parenthash() const;
  ::types::H256* _internal_mutable_parenthash();
  public:
  void unsafe_arena_set_allocated_parenthash(
      ::types::H256* parenthash);
  ::types::H256* unsafe_arena_release_parenthash();

  // .types.H160 coinbase = 2;
  bool has_coinbase() const;
  private:
  bool _internal_has_coinbase() const;
  public:
  void clear_coinbase();
  const ::types::H160& coinbase() const;
  PROTOBUF_NODISCARD ::types::H160* release_coinbase();
  ::types::H160* mutable_coinbase();
  void set_allocated_coinbase(::types::H160* coinbase);
  private:
  const ::types::H160& _internal_coinbase() const;
  ::types::H160* _internal_mutable_coinbase();
  public:
  void unsafe_arena_set_allocated_coinbase(
      ::types::H160* coinbase);
  ::types::H160* unsafe_arena_release_coinbase();

  // .types.H256 stateRoot = 3;
  bool has_stateroot() const;
  private:
  bool _internal_has_stateroot() const;
  public:
  void clear_stateroot();
  const ::types::H256& stateroot() const;
  PROTOBUF_NODISCARD ::types::H256* release_stateroot();
  ::types::H256* mutable_stateroot();
  void set_allocated_stateroot(::types::H256* stateroot);
  private:
  const ::types::H256& _internal_stateroot() const;
  ::types::H256* _internal_mutable_stateroot();
  public:
  void unsafe_arena_set_allocated_stateroot(
      ::types::H256* stateroot);
  ::types::H256* unsafe_arena_release_stateroot();

  // .types.H256 receiptRoot = 4;
  bool has_receiptroot() const;
  private:
  bool _internal_has_receiptroot() const;
  public:
  void clear_receiptroot();
  const ::types::H256& receiptroot() const;
  PROTOBUF_NODISCARD ::types::H256* release_receiptroot();
  ::types::H256* mutable_receiptroot();
  void set_allocated_receiptroot(::types::H256* receiptroot);
  private:
  const ::types::H256& _internal_receiptroot() const;
  ::types::H256* _internal_mutable_receiptroot();
  public:
  void unsafe_arena_set_allocated_receiptroot(
      ::types::H256* receiptroot);
  ::types::H256* unsafe_arena_release_receiptroot();

  // .types.H2048 logsBloom = 5;
  bool has_logsbloom() const;
  private:
  bool _internal_has_logsbloom() const;
  public:
  void clear_logsbloom();
  const ::types::H2048& logsbloom() const;
  PROTOBUF_NODISCARD ::types::H2048* release_logsbloom();
  ::types::H2048* mutable_logsbloom();
  void set_allocated_logsbloom(::types::H2048* logsbloom);
  private:
  const ::types::H2048& _internal_logsbloom() const;
  ::types::H2048* _internal_mutable_logsbloom();
  public:
  void unsafe_arena_set_allocated_logsbloom(
      ::types::H2048* logsbloom);
  ::types::H2048* unsafe_arena_release_logsbloom();

  // .types.H256 prevRandao = 6;
  bool has_prevrandao() const;
  private:
  bool _internal_has_prevrandao() const;
  public:
  void clear_prevrandao();
  const ::types::H256& prevrandao() const;
  PROTOBUF_NODISCARD ::types::H256* release_prevrandao();
  ::types::H256* mutable_prevrandao();
  void set_allocated_prevrandao(::types::H256* prevrandao);
  private:
  const ::types::H256& _internal_prevrandao() const;
  ::types::H256* _internal_mutable_prevrandao();
  public:
  void unsafe_arena_set_allocated_prevrandao(
      ::types::H256* prevrandao);
  ::types::H256* unsafe_arena_release_prevrandao();

  // .types.H256 baseFeePerGas = 12;
  bool has_basefeepergas() const;
  private:
  bool _internal_has_basefeepergas() const;
  public:
  void clear_basefeepergas();
  const ::types::H256& basefeepergas() const;
  PROTOBUF_NODISCARD ::types::H256* release_basefeepergas();
  ::types::H256* mutable_basefeepergas();
  void set_allocated_basefeepergas(::types::H256* basefeepergas);
  private:
  const ::types::H256& _internal_basefeepergas() const;
  ::types::H256* _internal_mutable_basefeepergas();
  public:
  void unsafe_arena_set_allocated_basefeepergas(
      ::types::H256* basefeepergas);
  ::types::H256* unsafe_arena_release_basefeepergas();

  // .types.H256 blockHash = 13;
  bool has_blockhash() const;
  private:
  bool _internal_has_blockhash() const;
  public:
  void clear_blockhash();
  const ::types::H256& blockhash() const;
  PROTOBUF_NODISCARD ::types::H256* release_blockhash();
  ::types::H256* mutable_blockhash();
  void set_allocated_blockhash(::types::H256* blockhash);
  private:
  const ::types::H256& _internal_blockhash() const;
  ::types::H256* _internal_mutable_blockhash();
  public:
  void unsafe_arena_set_allocated_blockhash(
      ::types::H256* blockhash);
  ::types::H256* unsafe_arena_release_blockhash();

  // uint64 blockNumber = 7;
  void clear_blocknumber();
  uint64_t blocknumber() const;
  void set_blocknumber(uint64_t value);
  private:
  uint64_t _internal_blocknumber() const;
  void _internal_set_blocknumber(uint64_t value);
  public:

  // uint64 gasLimit = 8;
  void clear_gaslimit();
  uint64_t gaslimit() const;
  void set_gaslimit(uint64_t value);
  private:
  uint64_t _internal_gaslimit() const;
  void _internal_set_gaslimit(uint64_t value);
  public:

  // uint64 gasUsed = 9;
  void clear_gasused();
  uint64_t gasused() const;
  void set_gasused(uint64_t value);
  private:
  uint64_t _internal_gasused() const;
  void _internal_set_gasused(uint64_t value);
  public:

  // uint64 timestamp = 10;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.ExecutionPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transactions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extradata_;
    ::types::H256* parenthash_;
    ::types::H160* coinbase_;
    ::types::H256* stateroot_;
    ::types::H256* receiptroot_;
    ::types::H2048* logsbloom_;
    ::types::H256* prevrandao_;
    ::types::H256* basefeepergas_;
    ::types::H256* blockhash_;
    uint64_t blocknumber_;
    uint64_t gaslimit_;
    uint64_t gasused_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Withdrawal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.Withdrawal) */ {
 public:
  inline Withdrawal() : Withdrawal(nullptr) {}
  ~Withdrawal() override;
  explicit PROTOBUF_CONSTEXPR Withdrawal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Withdrawal(const Withdrawal& from);
  Withdrawal(Withdrawal&& from) noexcept
    : Withdrawal() {
    *this = ::std::move(from);
  }

  inline Withdrawal& operator=(const Withdrawal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Withdrawal& operator=(Withdrawal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Withdrawal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Withdrawal* internal_default_instance() {
    return reinterpret_cast<const Withdrawal*>(
               &_Withdrawal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Withdrawal& a, Withdrawal& b) {
    a.Swap(&b);
  }
  inline void Swap(Withdrawal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Withdrawal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Withdrawal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Withdrawal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Withdrawal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Withdrawal& from) {
    Withdrawal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Withdrawal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.Withdrawal";
  }
  protected:
  explicit Withdrawal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 3,
    kAmountFieldNumber = 4,
    kIndexFieldNumber = 1,
    kValidatorIndexFieldNumber = 2,
  };
  // .types.H160 address = 3;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::types::H160& address() const;
  PROTOBUF_NODISCARD ::types::H160* release_address();
  ::types::H160* mutable_address();
  void set_allocated_address(::types::H160* address);
  private:
  const ::types::H160& _internal_address() const;
  ::types::H160* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::types::H160* address);
  ::types::H160* unsafe_arena_release_address();

  // .types.H256 amount = 4;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  const ::types::H256& amount() const;
  PROTOBUF_NODISCARD ::types::H256* release_amount();
  ::types::H256* mutable_amount();
  void set_allocated_amount(::types::H256* amount);
  private:
  const ::types::H256& _internal_amount() const;
  ::types::H256* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::types::H256* amount);
  ::types::H256* unsafe_arena_release_amount();

  // uint64 index = 1;
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // uint64 validatorIndex = 2;
  void clear_validatorindex();
  uint64_t validatorindex() const;
  void set_validatorindex(uint64_t value);
  private:
  uint64_t _internal_validatorindex() const;
  void _internal_set_validatorindex(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.Withdrawal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::types::H160* address_;
    ::types::H256* amount_;
    uint64_t index_;
    uint64_t validatorindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ExecutionPayloadV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.ExecutionPayloadV2) */ {
 public:
  inline ExecutionPayloadV2() : ExecutionPayloadV2(nullptr) {}
  ~ExecutionPayloadV2() override;
  explicit PROTOBUF_CONSTEXPR ExecutionPayloadV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionPayloadV2(const ExecutionPayloadV2& from);
  ExecutionPayloadV2(ExecutionPayloadV2&& from) noexcept
    : ExecutionPayloadV2() {
    *this = ::std::move(from);
  }

  inline ExecutionPayloadV2& operator=(const ExecutionPayloadV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionPayloadV2& operator=(ExecutionPayloadV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionPayloadV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionPayloadV2* internal_default_instance() {
    return reinterpret_cast<const ExecutionPayloadV2*>(
               &_ExecutionPayloadV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ExecutionPayloadV2& a, ExecutionPayloadV2& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionPayloadV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionPayloadV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionPayloadV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionPayloadV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionPayloadV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecutionPayloadV2& from) {
    ExecutionPayloadV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionPayloadV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.ExecutionPayloadV2";
  }
  protected:
  explicit ExecutionPayloadV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWithdrawalsFieldNumber = 2,
    kPayloadFieldNumber = 1,
  };
  // repeated .types.Withdrawal withdrawals = 2;
  int withdrawals_size() const;
  private:
  int _internal_withdrawals_size() const;
  public:
  void clear_withdrawals();
  ::types::Withdrawal* mutable_withdrawals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >*
      mutable_withdrawals();
  private:
  const ::types::Withdrawal& _internal_withdrawals(int index) const;
  ::types::Withdrawal* _internal_add_withdrawals();
  public:
  const ::types::Withdrawal& withdrawals(int index) const;
  ::types::Withdrawal* add_withdrawals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >&
      withdrawals() const;

  // .types.ExecutionPayload payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::types::ExecutionPayload& payload() const;
  PROTOBUF_NODISCARD ::types::ExecutionPayload* release_payload();
  ::types::ExecutionPayload* mutable_payload();
  void set_allocated_payload(::types::ExecutionPayload* payload);
  private:
  const ::types::ExecutionPayload& _internal_payload() const;
  ::types::ExecutionPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::types::ExecutionPayload* payload);
  ::types::ExecutionPayload* unsafe_arena_release_payload();

  // @@protoc_insertion_point(class_scope:types.ExecutionPayloadV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal > withdrawals_;
    ::types::ExecutionPayload* payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class NodeInfoPorts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.NodeInfoPorts) */ {
 public:
  inline NodeInfoPorts() : NodeInfoPorts(nullptr) {}
  ~NodeInfoPorts() override;
  explicit PROTOBUF_CONSTEXPR NodeInfoPorts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfoPorts(const NodeInfoPorts& from);
  NodeInfoPorts(NodeInfoPorts&& from) noexcept
    : NodeInfoPorts() {
    *this = ::std::move(from);
  }

  inline NodeInfoPorts& operator=(const NodeInfoPorts& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoPorts& operator=(NodeInfoPorts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfoPorts& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfoPorts* internal_default_instance() {
    return reinterpret_cast<const NodeInfoPorts*>(
               &_NodeInfoPorts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NodeInfoPorts& a, NodeInfoPorts& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfoPorts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoPorts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfoPorts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfoPorts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfoPorts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeInfoPorts& from) {
    NodeInfoPorts::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfoPorts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.NodeInfoPorts";
  }
  protected:
  explicit NodeInfoPorts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiscoveryFieldNumber = 1,
    kListenerFieldNumber = 2,
  };
  // uint32 discovery = 1;
  void clear_discovery();
  uint32_t discovery() const;
  void set_discovery(uint32_t value);
  private:
  uint32_t _internal_discovery() const;
  void _internal_set_discovery(uint32_t value);
  public:

  // uint32 listener = 2;
  void clear_listener();
  uint32_t listener() const;
  void set_listener(uint32_t value);
  private:
  uint32_t _internal_listener() const;
  void _internal_set_listener(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:types.NodeInfoPorts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t discovery_;
    uint32_t listener_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class NodeInfoReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.NodeInfoReply) */ {
 public:
  inline NodeInfoReply() : NodeInfoReply(nullptr) {}
  ~NodeInfoReply() override;
  explicit PROTOBUF_CONSTEXPR NodeInfoReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfoReply(const NodeInfoReply& from);
  NodeInfoReply(NodeInfoReply&& from) noexcept
    : NodeInfoReply() {
    *this = ::std::move(from);
  }

  inline NodeInfoReply& operator=(const NodeInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoReply& operator=(NodeInfoReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfoReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfoReply* internal_default_instance() {
    return reinterpret_cast<const NodeInfoReply*>(
               &_NodeInfoReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NodeInfoReply& a, NodeInfoReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfoReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfoReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfoReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfoReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeInfoReply& from) {
    NodeInfoReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfoReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.NodeInfoReply";
  }
  protected:
  explicit NodeInfoReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kEnodeFieldNumber = 3,
    kEnrFieldNumber = 4,
    kListenerAddrFieldNumber = 6,
    kProtocolsFieldNumber = 7,
    kPortsFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string enode = 3;
  void clear_enode();
  const std::string& enode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enode();
  PROTOBUF_NODISCARD std::string* release_enode();
  void set_allocated_enode(std::string* enode);
  private:
  const std::string& _internal_enode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enode(const std::string& value);
  std::string* _internal_mutable_enode();
  public:

  // string enr = 4;
  void clear_enr();
  const std::string& enr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enr();
  PROTOBUF_NODISCARD std::string* release_enr();
  void set_allocated_enr(std::string* enr);
  private:
  const std::string& _internal_enr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enr(const std::string& value);
  std::string* _internal_mutable_enr();
  public:

  // string listenerAddr = 6;
  void clear_listeneraddr();
  const std::string& listeneraddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_listeneraddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_listeneraddr();
  PROTOBUF_NODISCARD std::string* release_listeneraddr();
  void set_allocated_listeneraddr(std::string* listeneraddr);
  private:
  const std::string& _internal_listeneraddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_listeneraddr(const std::string& value);
  std::string* _internal_mutable_listeneraddr();
  public:

  // bytes protocols = 7;
  void clear_protocols();
  const std::string& protocols() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocols(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocols();
  PROTOBUF_NODISCARD std::string* release_protocols();
  void set_allocated_protocols(std::string* protocols);
  private:
  const std::string& _internal_protocols() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocols(const std::string& value);
  std::string* _internal_mutable_protocols();
  public:

  // .types.NodeInfoPorts ports = 5;
  bool has_ports() const;
  private:
  bool _internal_has_ports() const;
  public:
  void clear_ports();
  const ::types::NodeInfoPorts& ports() const;
  PROTOBUF_NODISCARD ::types::NodeInfoPorts* release_ports();
  ::types::NodeInfoPorts* mutable_ports();
  void set_allocated_ports(::types::NodeInfoPorts* ports);
  private:
  const ::types::NodeInfoPorts& _internal_ports() const;
  ::types::NodeInfoPorts* _internal_mutable_ports();
  public:
  void unsafe_arena_set_allocated_ports(
      ::types::NodeInfoPorts* ports);
  ::types::NodeInfoPorts* unsafe_arena_release_ports();

  // @@protoc_insertion_point(class_scope:types.NodeInfoReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr listeneraddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocols_;
    ::types::NodeInfoPorts* ports_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class PeerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:types.PeerInfo) */ {
 public:
  inline PeerInfo() : PeerInfo(nullptr) {}
  ~PeerInfo() override;
  explicit PROTOBUF_CONSTEXPR PeerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerInfo(const PeerInfo& from);
  PeerInfo(PeerInfo&& from) noexcept
    : PeerInfo() {
    *this = ::std::move(from);
  }

  inline PeerInfo& operator=(const PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerInfo& operator=(PeerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerInfo* internal_default_instance() {
    return reinterpret_cast<const PeerInfo*>(
               &_PeerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PeerInfo& a, PeerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeerInfo& from) {
    PeerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "types.PeerInfo";
  }
  protected:
  explicit PeerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapsFieldNumber = 5,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kEnodeFieldNumber = 3,
    kEnrFieldNumber = 4,
    kConnLocalAddrFieldNumber = 6,
    kConnRemoteAddrFieldNumber = 7,
    kConnIsInboundFieldNumber = 8,
    kConnIsTrustedFieldNumber = 9,
    kConnIsStaticFieldNumber = 10,
  };
  // repeated string caps = 5;
  int caps_size() const;
  private:
  int _internal_caps_size() const;
  public:
  void clear_caps();
  const std::string& caps(int index) const;
  std::string* mutable_caps(int index);
  void set_caps(int index, const std::string& value);
  void set_caps(int index, std::string&& value);
  void set_caps(int index, const char* value);
  void set_caps(int index, const char* value, size_t size);
  std::string* add_caps();
  void add_caps(const std::string& value);
  void add_caps(std::string&& value);
  void add_caps(const char* value);
  void add_caps(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& caps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_caps();
  private:
  const std::string& _internal_caps(int index) const;
  std::string* _internal_add_caps();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string enode = 3;
  void clear_enode();
  const std::string& enode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enode();
  PROTOBUF_NODISCARD std::string* release_enode();
  void set_allocated_enode(std::string* enode);
  private:
  const std::string& _internal_enode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enode(const std::string& value);
  std::string* _internal_mutable_enode();
  public:

  // string enr = 4;
  void clear_enr();
  const std::string& enr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enr();
  PROTOBUF_NODISCARD std::string* release_enr();
  void set_allocated_enr(std::string* enr);
  private:
  const std::string& _internal_enr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enr(const std::string& value);
  std::string* _internal_mutable_enr();
  public:

  // string connLocalAddr = 6;
  void clear_connlocaladdr();
  const std::string& connlocaladdr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connlocaladdr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connlocaladdr();
  PROTOBUF_NODISCARD std::string* release_connlocaladdr();
  void set_allocated_connlocaladdr(std::string* connlocaladdr);
  private:
  const std::string& _internal_connlocaladdr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connlocaladdr(const std::string& value);
  std::string* _internal_mutable_connlocaladdr();
  public:

  // string connRemoteAddr = 7;
  void clear_connremoteaddr();
  const std::string& connremoteaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connremoteaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connremoteaddr();
  PROTOBUF_NODISCARD std::string* release_connremoteaddr();
  void set_allocated_connremoteaddr(std::string* connremoteaddr);
  private:
  const std::string& _internal_connremoteaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connremoteaddr(const std::string& value);
  std::string* _internal_mutable_connremoteaddr();
  public:

  // bool connIsInbound = 8;
  void clear_connisinbound();
  bool connisinbound() const;
  void set_connisinbound(bool value);
  private:
  bool _internal_connisinbound() const;
  void _internal_set_connisinbound(bool value);
  public:

  // bool connIsTrusted = 9;
  void clear_connistrusted();
  bool connistrusted() const;
  void set_connistrusted(bool value);
  private:
  bool _internal_connistrusted() const;
  void _internal_set_connistrusted(bool value);
  public:

  // bool connIsStatic = 10;
  void clear_connisstatic();
  bool connisstatic() const;
  void set_connisstatic(bool value);
  private:
  bool _internal_connisstatic() const;
  void _internal_set_connisstatic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:types.PeerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> caps_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connlocaladdr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connremoteaddr_;
    bool connisinbound_;
    bool connistrusted_;
    bool connisstatic_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2ftypes_2eproto;
};
// ===================================================================

static const int kServiceMajorVersionFieldNumber = 50001;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< uint32_t >, 13, false >
  service_major_version;
static const int kServiceMinorVersionFieldNumber = 50002;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< uint32_t >, 13, false >
  service_minor_version;
static const int kServicePatchVersionFieldNumber = 50003;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< uint32_t >, 13, false >
  service_patch_version;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// H128

// uint64 hi = 1;
inline void H128::clear_hi() {
  _impl_.hi_ = uint64_t{0u};
}
inline uint64_t H128::_internal_hi() const {
  return _impl_.hi_;
}
inline uint64_t H128::hi() const {
  // @@protoc_insertion_point(field_get:types.H128.hi)
  return _internal_hi();
}
inline void H128::_internal_set_hi(uint64_t value) {
  
  _impl_.hi_ = value;
}
inline void H128::set_hi(uint64_t value) {
  _internal_set_hi(value);
  // @@protoc_insertion_point(field_set:types.H128.hi)
}

// uint64 lo = 2;
inline void H128::clear_lo() {
  _impl_.lo_ = uint64_t{0u};
}
inline uint64_t H128::_internal_lo() const {
  return _impl_.lo_;
}
inline uint64_t H128::lo() const {
  // @@protoc_insertion_point(field_get:types.H128.lo)
  return _internal_lo();
}
inline void H128::_internal_set_lo(uint64_t value) {
  
  _impl_.lo_ = value;
}
inline void H128::set_lo(uint64_t value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:types.H128.lo)
}

// -------------------------------------------------------------------

// H160

// .types.H128 hi = 1;
inline bool H160::_internal_has_hi() const {
  return this != internal_default_instance() && _impl_.hi_ != nullptr;
}
inline bool H160::has_hi() const {
  return _internal_has_hi();
}
inline void H160::clear_hi() {
  if (GetArenaForAllocation() == nullptr && _impl_.hi_ != nullptr) {
    delete _impl_.hi_;
  }
  _impl_.hi_ = nullptr;
}
inline const ::types::H128& H160::_internal_hi() const {
  const ::types::H128* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H128&>(
      ::types::_H128_default_instance_);
}
inline const ::types::H128& H160::hi() const {
  // @@protoc_insertion_point(field_get:types.H160.hi)
  return _internal_hi();
}
inline void H160::unsafe_arena_set_allocated_hi(
    ::types::H128* hi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H160.hi)
}
inline ::types::H128* H160::release_hi() {
  
  ::types::H128* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H128* H160::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H160.hi)
  
  ::types::H128* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H128* H160::_internal_mutable_hi() {
  
  if (_impl_.hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H128>(GetArenaForAllocation());
    _impl_.hi_ = p;
  }
  return _impl_.hi_;
}
inline ::types::H128* H160::mutable_hi() {
  ::types::H128* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H160.hi)
  return _msg;
}
inline void H160::set_allocated_hi(::types::H128* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H160.hi)
}

// uint32 lo = 2;
inline void H160::clear_lo() {
  _impl_.lo_ = 0u;
}
inline uint32_t H160::_internal_lo() const {
  return _impl_.lo_;
}
inline uint32_t H160::lo() const {
  // @@protoc_insertion_point(field_get:types.H160.lo)
  return _internal_lo();
}
inline void H160::_internal_set_lo(uint32_t value) {
  
  _impl_.lo_ = value;
}
inline void H160::set_lo(uint32_t value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:types.H160.lo)
}

// -------------------------------------------------------------------

// H256

// .types.H128 hi = 1;
inline bool H256::_internal_has_hi() const {
  return this != internal_default_instance() && _impl_.hi_ != nullptr;
}
inline bool H256::has_hi() const {
  return _internal_has_hi();
}
inline void H256::clear_hi() {
  if (GetArenaForAllocation() == nullptr && _impl_.hi_ != nullptr) {
    delete _impl_.hi_;
  }
  _impl_.hi_ = nullptr;
}
inline const ::types::H128& H256::_internal_hi() const {
  const ::types::H128* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H128&>(
      ::types::_H128_default_instance_);
}
inline const ::types::H128& H256::hi() const {
  // @@protoc_insertion_point(field_get:types.H256.hi)
  return _internal_hi();
}
inline void H256::unsafe_arena_set_allocated_hi(
    ::types::H128* hi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H256.hi)
}
inline ::types::H128* H256::release_hi() {
  
  ::types::H128* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H128* H256::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H256.hi)
  
  ::types::H128* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H128* H256::_internal_mutable_hi() {
  
  if (_impl_.hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H128>(GetArenaForAllocation());
    _impl_.hi_ = p;
  }
  return _impl_.hi_;
}
inline ::types::H128* H256::mutable_hi() {
  ::types::H128* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H256.hi)
  return _msg;
}
inline void H256::set_allocated_hi(::types::H128* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H256.hi)
}

// .types.H128 lo = 2;
inline bool H256::_internal_has_lo() const {
  return this != internal_default_instance() && _impl_.lo_ != nullptr;
}
inline bool H256::has_lo() const {
  return _internal_has_lo();
}
inline void H256::clear_lo() {
  if (GetArenaForAllocation() == nullptr && _impl_.lo_ != nullptr) {
    delete _impl_.lo_;
  }
  _impl_.lo_ = nullptr;
}
inline const ::types::H128& H256::_internal_lo() const {
  const ::types::H128* p = _impl_.lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H128&>(
      ::types::_H128_default_instance_);
}
inline const ::types::H128& H256::lo() const {
  // @@protoc_insertion_point(field_get:types.H256.lo)
  return _internal_lo();
}
inline void H256::unsafe_arena_set_allocated_lo(
    ::types::H128* lo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lo_);
  }
  _impl_.lo_ = lo;
  if (lo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H256.lo)
}
inline ::types::H128* H256::release_lo() {
  
  ::types::H128* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H128* H256::unsafe_arena_release_lo() {
  // @@protoc_insertion_point(field_release:types.H256.lo)
  
  ::types::H128* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
  return temp;
}
inline ::types::H128* H256::_internal_mutable_lo() {
  
  if (_impl_.lo_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H128>(GetArenaForAllocation());
    _impl_.lo_ = p;
  }
  return _impl_.lo_;
}
inline ::types::H128* H256::mutable_lo() {
  ::types::H128* _msg = _internal_mutable_lo();
  // @@protoc_insertion_point(field_mutable:types.H256.lo)
  return _msg;
}
inline void H256::set_allocated_lo(::types::H128* lo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lo_;
  }
  if (lo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lo);
    if (message_arena != submessage_arena) {
      lo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lo_ = lo;
  // @@protoc_insertion_point(field_set_allocated:types.H256.lo)
}

// -------------------------------------------------------------------

// H512

// .types.H256 hi = 1;
inline bool H512::_internal_has_hi() const {
  return this != internal_default_instance() && _impl_.hi_ != nullptr;
}
inline bool H512::has_hi() const {
  return _internal_has_hi();
}
inline void H512::clear_hi() {
  if (GetArenaForAllocation() == nullptr && _impl_.hi_ != nullptr) {
    delete _impl_.hi_;
  }
  _impl_.hi_ = nullptr;
}
inline const ::types::H256& H512::_internal_hi() const {
  const ::types::H256* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& H512::hi() const {
  // @@protoc_insertion_point(field_get:types.H512.hi)
  return _internal_hi();
}
inline void H512::unsafe_arena_set_allocated_hi(
    ::types::H256* hi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H512.hi)
}
inline ::types::H256* H512::release_hi() {
  
  ::types::H256* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* H512::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H512.hi)
  
  ::types::H256* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H256* H512::_internal_mutable_hi() {
  
  if (_impl_.hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.hi_ = p;
  }
  return _impl_.hi_;
}
inline ::types::H256* H512::mutable_hi() {
  ::types::H256* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H512.hi)
  return _msg;
}
inline void H512::set_allocated_hi(::types::H256* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H512.hi)
}

// .types.H256 lo = 2;
inline bool H512::_internal_has_lo() const {
  return this != internal_default_instance() && _impl_.lo_ != nullptr;
}
inline bool H512::has_lo() const {
  return _internal_has_lo();
}
inline void H512::clear_lo() {
  if (GetArenaForAllocation() == nullptr && _impl_.lo_ != nullptr) {
    delete _impl_.lo_;
  }
  _impl_.lo_ = nullptr;
}
inline const ::types::H256& H512::_internal_lo() const {
  const ::types::H256* p = _impl_.lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& H512::lo() const {
  // @@protoc_insertion_point(field_get:types.H512.lo)
  return _internal_lo();
}
inline void H512::unsafe_arena_set_allocated_lo(
    ::types::H256* lo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lo_);
  }
  _impl_.lo_ = lo;
  if (lo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H512.lo)
}
inline ::types::H256* H512::release_lo() {
  
  ::types::H256* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* H512::unsafe_arena_release_lo() {
  // @@protoc_insertion_point(field_release:types.H512.lo)
  
  ::types::H256* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
  return temp;
}
inline ::types::H256* H512::_internal_mutable_lo() {
  
  if (_impl_.lo_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.lo_ = p;
  }
  return _impl_.lo_;
}
inline ::types::H256* H512::mutable_lo() {
  ::types::H256* _msg = _internal_mutable_lo();
  // @@protoc_insertion_point(field_mutable:types.H512.lo)
  return _msg;
}
inline void H512::set_allocated_lo(::types::H256* lo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lo_;
  }
  if (lo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lo);
    if (message_arena != submessage_arena) {
      lo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lo_ = lo;
  // @@protoc_insertion_point(field_set_allocated:types.H512.lo)
}

// -------------------------------------------------------------------

// H1024

// .types.H512 hi = 1;
inline bool H1024::_internal_has_hi() const {
  return this != internal_default_instance() && _impl_.hi_ != nullptr;
}
inline bool H1024::has_hi() const {
  return _internal_has_hi();
}
inline void H1024::clear_hi() {
  if (GetArenaForAllocation() == nullptr && _impl_.hi_ != nullptr) {
    delete _impl_.hi_;
  }
  _impl_.hi_ = nullptr;
}
inline const ::types::H512& H1024::_internal_hi() const {
  const ::types::H512* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& H1024::hi() const {
  // @@protoc_insertion_point(field_get:types.H1024.hi)
  return _internal_hi();
}
inline void H1024::unsafe_arena_set_allocated_hi(
    ::types::H512* hi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H1024.hi)
}
inline ::types::H512* H1024::release_hi() {
  
  ::types::H512* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H512* H1024::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H1024.hi)
  
  ::types::H512* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H512* H1024::_internal_mutable_hi() {
  
  if (_impl_.hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArenaForAllocation());
    _impl_.hi_ = p;
  }
  return _impl_.hi_;
}
inline ::types::H512* H1024::mutable_hi() {
  ::types::H512* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H1024.hi)
  return _msg;
}
inline void H1024::set_allocated_hi(::types::H512* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H1024.hi)
}

// .types.H512 lo = 2;
inline bool H1024::_internal_has_lo() const {
  return this != internal_default_instance() && _impl_.lo_ != nullptr;
}
inline bool H1024::has_lo() const {
  return _internal_has_lo();
}
inline void H1024::clear_lo() {
  if (GetArenaForAllocation() == nullptr && _impl_.lo_ != nullptr) {
    delete _impl_.lo_;
  }
  _impl_.lo_ = nullptr;
}
inline const ::types::H512& H1024::_internal_lo() const {
  const ::types::H512* p = _impl_.lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H512&>(
      ::types::_H512_default_instance_);
}
inline const ::types::H512& H1024::lo() const {
  // @@protoc_insertion_point(field_get:types.H1024.lo)
  return _internal_lo();
}
inline void H1024::unsafe_arena_set_allocated_lo(
    ::types::H512* lo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lo_);
  }
  _impl_.lo_ = lo;
  if (lo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H1024.lo)
}
inline ::types::H512* H1024::release_lo() {
  
  ::types::H512* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H512* H1024::unsafe_arena_release_lo() {
  // @@protoc_insertion_point(field_release:types.H1024.lo)
  
  ::types::H512* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
  return temp;
}
inline ::types::H512* H1024::_internal_mutable_lo() {
  
  if (_impl_.lo_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H512>(GetArenaForAllocation());
    _impl_.lo_ = p;
  }
  return _impl_.lo_;
}
inline ::types::H512* H1024::mutable_lo() {
  ::types::H512* _msg = _internal_mutable_lo();
  // @@protoc_insertion_point(field_mutable:types.H1024.lo)
  return _msg;
}
inline void H1024::set_allocated_lo(::types::H512* lo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lo_;
  }
  if (lo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lo);
    if (message_arena != submessage_arena) {
      lo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lo_ = lo;
  // @@protoc_insertion_point(field_set_allocated:types.H1024.lo)
}

// -------------------------------------------------------------------

// H2048

// .types.H1024 hi = 1;
inline bool H2048::_internal_has_hi() const {
  return this != internal_default_instance() && _impl_.hi_ != nullptr;
}
inline bool H2048::has_hi() const {
  return _internal_has_hi();
}
inline void H2048::clear_hi() {
  if (GetArenaForAllocation() == nullptr && _impl_.hi_ != nullptr) {
    delete _impl_.hi_;
  }
  _impl_.hi_ = nullptr;
}
inline const ::types::H1024& H2048::_internal_hi() const {
  const ::types::H1024* p = _impl_.hi_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H1024&>(
      ::types::_H1024_default_instance_);
}
inline const ::types::H1024& H2048::hi() const {
  // @@protoc_insertion_point(field_get:types.H2048.hi)
  return _internal_hi();
}
inline void H2048::unsafe_arena_set_allocated_hi(
    ::types::H1024* hi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hi_);
  }
  _impl_.hi_ = hi;
  if (hi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H2048.hi)
}
inline ::types::H1024* H2048::release_hi() {
  
  ::types::H1024* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H1024* H2048::unsafe_arena_release_hi() {
  // @@protoc_insertion_point(field_release:types.H2048.hi)
  
  ::types::H1024* temp = _impl_.hi_;
  _impl_.hi_ = nullptr;
  return temp;
}
inline ::types::H1024* H2048::_internal_mutable_hi() {
  
  if (_impl_.hi_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H1024>(GetArenaForAllocation());
    _impl_.hi_ = p;
  }
  return _impl_.hi_;
}
inline ::types::H1024* H2048::mutable_hi() {
  ::types::H1024* _msg = _internal_mutable_hi();
  // @@protoc_insertion_point(field_mutable:types.H2048.hi)
  return _msg;
}
inline void H2048::set_allocated_hi(::types::H1024* hi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hi_;
  }
  if (hi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hi);
    if (message_arena != submessage_arena) {
      hi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hi, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hi_ = hi;
  // @@protoc_insertion_point(field_set_allocated:types.H2048.hi)
}

// .types.H1024 lo = 2;
inline bool H2048::_internal_has_lo() const {
  return this != internal_default_instance() && _impl_.lo_ != nullptr;
}
inline bool H2048::has_lo() const {
  return _internal_has_lo();
}
inline void H2048::clear_lo() {
  if (GetArenaForAllocation() == nullptr && _impl_.lo_ != nullptr) {
    delete _impl_.lo_;
  }
  _impl_.lo_ = nullptr;
}
inline const ::types::H1024& H2048::_internal_lo() const {
  const ::types::H1024* p = _impl_.lo_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H1024&>(
      ::types::_H1024_default_instance_);
}
inline const ::types::H1024& H2048::lo() const {
  // @@protoc_insertion_point(field_get:types.H2048.lo)
  return _internal_lo();
}
inline void H2048::unsafe_arena_set_allocated_lo(
    ::types::H1024* lo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lo_);
  }
  _impl_.lo_ = lo;
  if (lo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.H2048.lo)
}
inline ::types::H1024* H2048::release_lo() {
  
  ::types::H1024* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H1024* H2048::unsafe_arena_release_lo() {
  // @@protoc_insertion_point(field_release:types.H2048.lo)
  
  ::types::H1024* temp = _impl_.lo_;
  _impl_.lo_ = nullptr;
  return temp;
}
inline ::types::H1024* H2048::_internal_mutable_lo() {
  
  if (_impl_.lo_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H1024>(GetArenaForAllocation());
    _impl_.lo_ = p;
  }
  return _impl_.lo_;
}
inline ::types::H1024* H2048::mutable_lo() {
  ::types::H1024* _msg = _internal_mutable_lo();
  // @@protoc_insertion_point(field_mutable:types.H2048.lo)
  return _msg;
}
inline void H2048::set_allocated_lo(::types::H1024* lo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lo_;
  }
  if (lo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lo);
    if (message_arena != submessage_arena) {
      lo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lo_ = lo;
  // @@protoc_insertion_point(field_set_allocated:types.H2048.lo)
}

// -------------------------------------------------------------------

// VersionReply

// uint32 major = 1;
inline void VersionReply::clear_major() {
  _impl_.major_ = 0u;
}
inline uint32_t VersionReply::_internal_major() const {
  return _impl_.major_;
}
inline uint32_t VersionReply::major() const {
  // @@protoc_insertion_point(field_get:types.VersionReply.major)
  return _internal_major();
}
inline void VersionReply::_internal_set_major(uint32_t value) {
  
  _impl_.major_ = value;
}
inline void VersionReply::set_major(uint32_t value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:types.VersionReply.major)
}

// uint32 minor = 2;
inline void VersionReply::clear_minor() {
  _impl_.minor_ = 0u;
}
inline uint32_t VersionReply::_internal_minor() const {
  return _impl_.minor_;
}
inline uint32_t VersionReply::minor() const {
  // @@protoc_insertion_point(field_get:types.VersionReply.minor)
  return _internal_minor();
}
inline void VersionReply::_internal_set_minor(uint32_t value) {
  
  _impl_.minor_ = value;
}
inline void VersionReply::set_minor(uint32_t value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:types.VersionReply.minor)
}

// uint32 patch = 3;
inline void VersionReply::clear_patch() {
  _impl_.patch_ = 0u;
}
inline uint32_t VersionReply::_internal_patch() const {
  return _impl_.patch_;
}
inline uint32_t VersionReply::patch() const {
  // @@protoc_insertion_point(field_get:types.VersionReply.patch)
  return _internal_patch();
}
inline void VersionReply::_internal_set_patch(uint32_t value) {
  
  _impl_.patch_ = value;
}
inline void VersionReply::set_patch(uint32_t value) {
  _internal_set_patch(value);
  // @@protoc_insertion_point(field_set:types.VersionReply.patch)
}

// -------------------------------------------------------------------

// ExecutionPayload

// .types.H256 parentHash = 1;
inline bool ExecutionPayload::_internal_has_parenthash() const {
  return this != internal_default_instance() && _impl_.parenthash_ != nullptr;
}
inline bool ExecutionPayload::has_parenthash() const {
  return _internal_has_parenthash();
}
inline void ExecutionPayload::clear_parenthash() {
  if (GetArenaForAllocation() == nullptr && _impl_.parenthash_ != nullptr) {
    delete _impl_.parenthash_;
  }
  _impl_.parenthash_ = nullptr;
}
inline const ::types::H256& ExecutionPayload::_internal_parenthash() const {
  const ::types::H256* p = _impl_.parenthash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::parenthash() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.parentHash)
  return _internal_parenthash();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_parenthash(
    ::types::H256* parenthash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parenthash_);
  }
  _impl_.parenthash_ = parenthash;
  if (parenthash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.parentHash)
}
inline ::types::H256* ExecutionPayload::release_parenthash() {
  
  ::types::H256* temp = _impl_.parenthash_;
  _impl_.parenthash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_parenthash() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.parentHash)
  
  ::types::H256* temp = _impl_.parenthash_;
  _impl_.parenthash_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_parenthash() {
  
  if (_impl_.parenthash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.parenthash_ = p;
  }
  return _impl_.parenthash_;
}
inline ::types::H256* ExecutionPayload::mutable_parenthash() {
  ::types::H256* _msg = _internal_mutable_parenthash();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.parentHash)
  return _msg;
}
inline void ExecutionPayload::set_allocated_parenthash(::types::H256* parenthash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parenthash_;
  }
  if (parenthash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parenthash);
    if (message_arena != submessage_arena) {
      parenthash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parenthash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parenthash_ = parenthash;
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.parentHash)
}

// .types.H160 coinbase = 2;
inline bool ExecutionPayload::_internal_has_coinbase() const {
  return this != internal_default_instance() && _impl_.coinbase_ != nullptr;
}
inline bool ExecutionPayload::has_coinbase() const {
  return _internal_has_coinbase();
}
inline void ExecutionPayload::clear_coinbase() {
  if (GetArenaForAllocation() == nullptr && _impl_.coinbase_ != nullptr) {
    delete _impl_.coinbase_;
  }
  _impl_.coinbase_ = nullptr;
}
inline const ::types::H160& ExecutionPayload::_internal_coinbase() const {
  const ::types::H160* p = _impl_.coinbase_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(
      ::types::_H160_default_instance_);
}
inline const ::types::H160& ExecutionPayload::coinbase() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.coinbase)
  return _internal_coinbase();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_coinbase(
    ::types::H160* coinbase) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coinbase_);
  }
  _impl_.coinbase_ = coinbase;
  if (coinbase) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.coinbase)
}
inline ::types::H160* ExecutionPayload::release_coinbase() {
  
  ::types::H160* temp = _impl_.coinbase_;
  _impl_.coinbase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H160* ExecutionPayload::unsafe_arena_release_coinbase() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.coinbase)
  
  ::types::H160* temp = _impl_.coinbase_;
  _impl_.coinbase_ = nullptr;
  return temp;
}
inline ::types::H160* ExecutionPayload::_internal_mutable_coinbase() {
  
  if (_impl_.coinbase_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArenaForAllocation());
    _impl_.coinbase_ = p;
  }
  return _impl_.coinbase_;
}
inline ::types::H160* ExecutionPayload::mutable_coinbase() {
  ::types::H160* _msg = _internal_mutable_coinbase();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.coinbase)
  return _msg;
}
inline void ExecutionPayload::set_allocated_coinbase(::types::H160* coinbase) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.coinbase_;
  }
  if (coinbase) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coinbase);
    if (message_arena != submessage_arena) {
      coinbase = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coinbase, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.coinbase_ = coinbase;
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.coinbase)
}

// .types.H256 stateRoot = 3;
inline bool ExecutionPayload::_internal_has_stateroot() const {
  return this != internal_default_instance() && _impl_.stateroot_ != nullptr;
}
inline bool ExecutionPayload::has_stateroot() const {
  return _internal_has_stateroot();
}
inline void ExecutionPayload::clear_stateroot() {
  if (GetArenaForAllocation() == nullptr && _impl_.stateroot_ != nullptr) {
    delete _impl_.stateroot_;
  }
  _impl_.stateroot_ = nullptr;
}
inline const ::types::H256& ExecutionPayload::_internal_stateroot() const {
  const ::types::H256* p = _impl_.stateroot_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::stateroot() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.stateRoot)
  return _internal_stateroot();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_stateroot(
    ::types::H256* stateroot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stateroot_);
  }
  _impl_.stateroot_ = stateroot;
  if (stateroot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.stateRoot)
}
inline ::types::H256* ExecutionPayload::release_stateroot() {
  
  ::types::H256* temp = _impl_.stateroot_;
  _impl_.stateroot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_stateroot() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.stateRoot)
  
  ::types::H256* temp = _impl_.stateroot_;
  _impl_.stateroot_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_stateroot() {
  
  if (_impl_.stateroot_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.stateroot_ = p;
  }
  return _impl_.stateroot_;
}
inline ::types::H256* ExecutionPayload::mutable_stateroot() {
  ::types::H256* _msg = _internal_mutable_stateroot();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.stateRoot)
  return _msg;
}
inline void ExecutionPayload::set_allocated_stateroot(::types::H256* stateroot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stateroot_;
  }
  if (stateroot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stateroot);
    if (message_arena != submessage_arena) {
      stateroot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stateroot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stateroot_ = stateroot;
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.stateRoot)
}

// .types.H256 receiptRoot = 4;
inline bool ExecutionPayload::_internal_has_receiptroot() const {
  return this != internal_default_instance() && _impl_.receiptroot_ != nullptr;
}
inline bool ExecutionPayload::has_receiptroot() const {
  return _internal_has_receiptroot();
}
inline void ExecutionPayload::clear_receiptroot() {
  if (GetArenaForAllocation() == nullptr && _impl_.receiptroot_ != nullptr) {
    delete _impl_.receiptroot_;
  }
  _impl_.receiptroot_ = nullptr;
}
inline const ::types::H256& ExecutionPayload::_internal_receiptroot() const {
  const ::types::H256* p = _impl_.receiptroot_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::receiptroot() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.receiptRoot)
  return _internal_receiptroot();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_receiptroot(
    ::types::H256* receiptroot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receiptroot_);
  }
  _impl_.receiptroot_ = receiptroot;
  if (receiptroot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.receiptRoot)
}
inline ::types::H256* ExecutionPayload::release_receiptroot() {
  
  ::types::H256* temp = _impl_.receiptroot_;
  _impl_.receiptroot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_receiptroot() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.receiptRoot)
  
  ::types::H256* temp = _impl_.receiptroot_;
  _impl_.receiptroot_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_receiptroot() {
  
  if (_impl_.receiptroot_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.receiptroot_ = p;
  }
  return _impl_.receiptroot_;
}
inline ::types::H256* ExecutionPayload::mutable_receiptroot() {
  ::types::H256* _msg = _internal_mutable_receiptroot();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.receiptRoot)
  return _msg;
}
inline void ExecutionPayload::set_allocated_receiptroot(::types::H256* receiptroot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.receiptroot_;
  }
  if (receiptroot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(receiptroot);
    if (message_arena != submessage_arena) {
      receiptroot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiptroot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.receiptroot_ = receiptroot;
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.receiptRoot)
}

// .types.H2048 logsBloom = 5;
inline bool ExecutionPayload::_internal_has_logsbloom() const {
  return this != internal_default_instance() && _impl_.logsbloom_ != nullptr;
}
inline bool ExecutionPayload::has_logsbloom() const {
  return _internal_has_logsbloom();
}
inline void ExecutionPayload::clear_logsbloom() {
  if (GetArenaForAllocation() == nullptr && _impl_.logsbloom_ != nullptr) {
    delete _impl_.logsbloom_;
  }
  _impl_.logsbloom_ = nullptr;
}
inline const ::types::H2048& ExecutionPayload::_internal_logsbloom() const {
  const ::types::H2048* p = _impl_.logsbloom_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H2048&>(
      ::types::_H2048_default_instance_);
}
inline const ::types::H2048& ExecutionPayload::logsbloom() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.logsBloom)
  return _internal_logsbloom();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_logsbloom(
    ::types::H2048* logsbloom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logsbloom_);
  }
  _impl_.logsbloom_ = logsbloom;
  if (logsbloom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.logsBloom)
}
inline ::types::H2048* ExecutionPayload::release_logsbloom() {
  
  ::types::H2048* temp = _impl_.logsbloom_;
  _impl_.logsbloom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H2048* ExecutionPayload::unsafe_arena_release_logsbloom() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.logsBloom)
  
  ::types::H2048* temp = _impl_.logsbloom_;
  _impl_.logsbloom_ = nullptr;
  return temp;
}
inline ::types::H2048* ExecutionPayload::_internal_mutable_logsbloom() {
  
  if (_impl_.logsbloom_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H2048>(GetArenaForAllocation());
    _impl_.logsbloom_ = p;
  }
  return _impl_.logsbloom_;
}
inline ::types::H2048* ExecutionPayload::mutable_logsbloom() {
  ::types::H2048* _msg = _internal_mutable_logsbloom();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.logsBloom)
  return _msg;
}
inline void ExecutionPayload::set_allocated_logsbloom(::types::H2048* logsbloom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logsbloom_;
  }
  if (logsbloom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logsbloom);
    if (message_arena != submessage_arena) {
      logsbloom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logsbloom, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.logsbloom_ = logsbloom;
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.logsBloom)
}

// .types.H256 prevRandao = 6;
inline bool ExecutionPayload::_internal_has_prevrandao() const {
  return this != internal_default_instance() && _impl_.prevrandao_ != nullptr;
}
inline bool ExecutionPayload::has_prevrandao() const {
  return _internal_has_prevrandao();
}
inline void ExecutionPayload::clear_prevrandao() {
  if (GetArenaForAllocation() == nullptr && _impl_.prevrandao_ != nullptr) {
    delete _impl_.prevrandao_;
  }
  _impl_.prevrandao_ = nullptr;
}
inline const ::types::H256& ExecutionPayload::_internal_prevrandao() const {
  const ::types::H256* p = _impl_.prevrandao_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::prevrandao() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.prevRandao)
  return _internal_prevrandao();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_prevrandao(
    ::types::H256* prevrandao) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prevrandao_);
  }
  _impl_.prevrandao_ = prevrandao;
  if (prevrandao) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.prevRandao)
}
inline ::types::H256* ExecutionPayload::release_prevrandao() {
  
  ::types::H256* temp = _impl_.prevrandao_;
  _impl_.prevrandao_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_prevrandao() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.prevRandao)
  
  ::types::H256* temp = _impl_.prevrandao_;
  _impl_.prevrandao_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_prevrandao() {
  
  if (_impl_.prevrandao_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.prevrandao_ = p;
  }
  return _impl_.prevrandao_;
}
inline ::types::H256* ExecutionPayload::mutable_prevrandao() {
  ::types::H256* _msg = _internal_mutable_prevrandao();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.prevRandao)
  return _msg;
}
inline void ExecutionPayload::set_allocated_prevrandao(::types::H256* prevrandao) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prevrandao_;
  }
  if (prevrandao) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prevrandao);
    if (message_arena != submessage_arena) {
      prevrandao = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prevrandao, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prevrandao_ = prevrandao;
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.prevRandao)
}

// uint64 blockNumber = 7;
inline void ExecutionPayload::clear_blocknumber() {
  _impl_.blocknumber_ = uint64_t{0u};
}
inline uint64_t ExecutionPayload::_internal_blocknumber() const {
  return _impl_.blocknumber_;
}
inline uint64_t ExecutionPayload::blocknumber() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.blockNumber)
  return _internal_blocknumber();
}
inline void ExecutionPayload::_internal_set_blocknumber(uint64_t value) {
  
  _impl_.blocknumber_ = value;
}
inline void ExecutionPayload::set_blocknumber(uint64_t value) {
  _internal_set_blocknumber(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.blockNumber)
}

// uint64 gasLimit = 8;
inline void ExecutionPayload::clear_gaslimit() {
  _impl_.gaslimit_ = uint64_t{0u};
}
inline uint64_t ExecutionPayload::_internal_gaslimit() const {
  return _impl_.gaslimit_;
}
inline uint64_t ExecutionPayload::gaslimit() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.gasLimit)
  return _internal_gaslimit();
}
inline void ExecutionPayload::_internal_set_gaslimit(uint64_t value) {
  
  _impl_.gaslimit_ = value;
}
inline void ExecutionPayload::set_gaslimit(uint64_t value) {
  _internal_set_gaslimit(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.gasLimit)
}

// uint64 gasUsed = 9;
inline void ExecutionPayload::clear_gasused() {
  _impl_.gasused_ = uint64_t{0u};
}
inline uint64_t ExecutionPayload::_internal_gasused() const {
  return _impl_.gasused_;
}
inline uint64_t ExecutionPayload::gasused() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.gasUsed)
  return _internal_gasused();
}
inline void ExecutionPayload::_internal_set_gasused(uint64_t value) {
  
  _impl_.gasused_ = value;
}
inline void ExecutionPayload::set_gasused(uint64_t value) {
  _internal_set_gasused(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.gasUsed)
}

// uint64 timestamp = 10;
inline void ExecutionPayload::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t ExecutionPayload::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t ExecutionPayload::timestamp() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.timestamp)
  return _internal_timestamp();
}
inline void ExecutionPayload::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ExecutionPayload::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.timestamp)
}

// bytes extraData = 11;
inline void ExecutionPayload::clear_extradata() {
  _impl_.extradata_.ClearToEmpty();
}
inline const std::string& ExecutionPayload::extradata() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.extraData)
  return _internal_extradata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionPayload::set_extradata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extradata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.extraData)
}
inline std::string* ExecutionPayload::mutable_extradata() {
  std::string* _s = _internal_mutable_extradata();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.extraData)
  return _s;
}
inline const std::string& ExecutionPayload::_internal_extradata() const {
  return _impl_.extradata_.Get();
}
inline void ExecutionPayload::_internal_set_extradata(const std::string& value) {
  
  _impl_.extradata_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionPayload::_internal_mutable_extradata() {
  
  return _impl_.extradata_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionPayload::release_extradata() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.extraData)
  return _impl_.extradata_.Release();
}
inline void ExecutionPayload::set_allocated_extradata(std::string* extradata) {
  if (extradata != nullptr) {
    
  } else {
    
  }
  _impl_.extradata_.SetAllocated(extradata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extradata_.IsDefault()) {
    _impl_.extradata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.extraData)
}

// .types.H256 baseFeePerGas = 12;
inline bool ExecutionPayload::_internal_has_basefeepergas() const {
  return this != internal_default_instance() && _impl_.basefeepergas_ != nullptr;
}
inline bool ExecutionPayload::has_basefeepergas() const {
  return _internal_has_basefeepergas();
}
inline void ExecutionPayload::clear_basefeepergas() {
  if (GetArenaForAllocation() == nullptr && _impl_.basefeepergas_ != nullptr) {
    delete _impl_.basefeepergas_;
  }
  _impl_.basefeepergas_ = nullptr;
}
inline const ::types::H256& ExecutionPayload::_internal_basefeepergas() const {
  const ::types::H256* p = _impl_.basefeepergas_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::basefeepergas() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.baseFeePerGas)
  return _internal_basefeepergas();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_basefeepergas(
    ::types::H256* basefeepergas) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.basefeepergas_);
  }
  _impl_.basefeepergas_ = basefeepergas;
  if (basefeepergas) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.baseFeePerGas)
}
inline ::types::H256* ExecutionPayload::release_basefeepergas() {
  
  ::types::H256* temp = _impl_.basefeepergas_;
  _impl_.basefeepergas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_basefeepergas() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.baseFeePerGas)
  
  ::types::H256* temp = _impl_.basefeepergas_;
  _impl_.basefeepergas_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_basefeepergas() {
  
  if (_impl_.basefeepergas_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.basefeepergas_ = p;
  }
  return _impl_.basefeepergas_;
}
inline ::types::H256* ExecutionPayload::mutable_basefeepergas() {
  ::types::H256* _msg = _internal_mutable_basefeepergas();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.baseFeePerGas)
  return _msg;
}
inline void ExecutionPayload::set_allocated_basefeepergas(::types::H256* basefeepergas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.basefeepergas_;
  }
  if (basefeepergas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basefeepergas);
    if (message_arena != submessage_arena) {
      basefeepergas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basefeepergas, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.basefeepergas_ = basefeepergas;
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.baseFeePerGas)
}

// .types.H256 blockHash = 13;
inline bool ExecutionPayload::_internal_has_blockhash() const {
  return this != internal_default_instance() && _impl_.blockhash_ != nullptr;
}
inline bool ExecutionPayload::has_blockhash() const {
  return _internal_has_blockhash();
}
inline void ExecutionPayload::clear_blockhash() {
  if (GetArenaForAllocation() == nullptr && _impl_.blockhash_ != nullptr) {
    delete _impl_.blockhash_;
  }
  _impl_.blockhash_ = nullptr;
}
inline const ::types::H256& ExecutionPayload::_internal_blockhash() const {
  const ::types::H256* p = _impl_.blockhash_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& ExecutionPayload::blockhash() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.blockHash)
  return _internal_blockhash();
}
inline void ExecutionPayload::unsafe_arena_set_allocated_blockhash(
    ::types::H256* blockhash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blockhash_);
  }
  _impl_.blockhash_ = blockhash;
  if (blockhash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayload.blockHash)
}
inline ::types::H256* ExecutionPayload::release_blockhash() {
  
  ::types::H256* temp = _impl_.blockhash_;
  _impl_.blockhash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* ExecutionPayload::unsafe_arena_release_blockhash() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayload.blockHash)
  
  ::types::H256* temp = _impl_.blockhash_;
  _impl_.blockhash_ = nullptr;
  return temp;
}
inline ::types::H256* ExecutionPayload::_internal_mutable_blockhash() {
  
  if (_impl_.blockhash_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.blockhash_ = p;
  }
  return _impl_.blockhash_;
}
inline ::types::H256* ExecutionPayload::mutable_blockhash() {
  ::types::H256* _msg = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.blockHash)
  return _msg;
}
inline void ExecutionPayload::set_allocated_blockhash(::types::H256* blockhash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.blockhash_;
  }
  if (blockhash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(blockhash);
    if (message_arena != submessage_arena) {
      blockhash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blockhash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blockhash_ = blockhash;
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayload.blockHash)
}

// repeated bytes transactions = 14;
inline int ExecutionPayload::_internal_transactions_size() const {
  return _impl_.transactions_.size();
}
inline int ExecutionPayload::transactions_size() const {
  return _internal_transactions_size();
}
inline void ExecutionPayload::clear_transactions() {
  _impl_.transactions_.Clear();
}
inline std::string* ExecutionPayload::add_transactions() {
  std::string* _s = _internal_add_transactions();
  // @@protoc_insertion_point(field_add_mutable:types.ExecutionPayload.transactions)
  return _s;
}
inline const std::string& ExecutionPayload::_internal_transactions(int index) const {
  return _impl_.transactions_.Get(index);
}
inline const std::string& ExecutionPayload::transactions(int index) const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayload.transactions)
  return _internal_transactions(index);
}
inline std::string* ExecutionPayload::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayload.transactions)
  return _impl_.transactions_.Mutable(index);
}
inline void ExecutionPayload::set_transactions(int index, const std::string& value) {
  _impl_.transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::set_transactions(int index, std::string&& value) {
  _impl_.transactions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::set_transactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::set_transactions(int index, const void* value, size_t size) {
  _impl_.transactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.ExecutionPayload.transactions)
}
inline std::string* ExecutionPayload::_internal_add_transactions() {
  return _impl_.transactions_.Add();
}
inline void ExecutionPayload::add_transactions(const std::string& value) {
  _impl_.transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::add_transactions(std::string&& value) {
  _impl_.transactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::add_transactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.ExecutionPayload.transactions)
}
inline void ExecutionPayload::add_transactions(const void* value, size_t size) {
  _impl_.transactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.ExecutionPayload.transactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecutionPayload::transactions() const {
  // @@protoc_insertion_point(field_list:types.ExecutionPayload.transactions)
  return _impl_.transactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecutionPayload::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:types.ExecutionPayload.transactions)
  return &_impl_.transactions_;
}

// -------------------------------------------------------------------

// Withdrawal

// uint64 index = 1;
inline void Withdrawal::clear_index() {
  _impl_.index_ = uint64_t{0u};
}
inline uint64_t Withdrawal::_internal_index() const {
  return _impl_.index_;
}
inline uint64_t Withdrawal::index() const {
  // @@protoc_insertion_point(field_get:types.Withdrawal.index)
  return _internal_index();
}
inline void Withdrawal::_internal_set_index(uint64_t value) {
  
  _impl_.index_ = value;
}
inline void Withdrawal::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:types.Withdrawal.index)
}

// uint64 validatorIndex = 2;
inline void Withdrawal::clear_validatorindex() {
  _impl_.validatorindex_ = uint64_t{0u};
}
inline uint64_t Withdrawal::_internal_validatorindex() const {
  return _impl_.validatorindex_;
}
inline uint64_t Withdrawal::validatorindex() const {
  // @@protoc_insertion_point(field_get:types.Withdrawal.validatorIndex)
  return _internal_validatorindex();
}
inline void Withdrawal::_internal_set_validatorindex(uint64_t value) {
  
  _impl_.validatorindex_ = value;
}
inline void Withdrawal::set_validatorindex(uint64_t value) {
  _internal_set_validatorindex(value);
  // @@protoc_insertion_point(field_set:types.Withdrawal.validatorIndex)
}

// .types.H160 address = 3;
inline bool Withdrawal::_internal_has_address() const {
  return this != internal_default_instance() && _impl_.address_ != nullptr;
}
inline bool Withdrawal::has_address() const {
  return _internal_has_address();
}
inline void Withdrawal::clear_address() {
  if (GetArenaForAllocation() == nullptr && _impl_.address_ != nullptr) {
    delete _impl_.address_;
  }
  _impl_.address_ = nullptr;
}
inline const ::types::H160& Withdrawal::_internal_address() const {
  const ::types::H160* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H160&>(
      ::types::_H160_default_instance_);
}
inline const ::types::H160& Withdrawal::address() const {
  // @@protoc_insertion_point(field_get:types.Withdrawal.address)
  return _internal_address();
}
inline void Withdrawal::unsafe_arena_set_allocated_address(
    ::types::H160* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.Withdrawal.address)
}
inline ::types::H160* Withdrawal::release_address() {
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H160* Withdrawal::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:types.Withdrawal.address)
  
  ::types::H160* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::types::H160* Withdrawal::_internal_mutable_address() {
  
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H160>(GetArenaForAllocation());
    _impl_.address_ = p;
  }
  return _impl_.address_;
}
inline ::types::H160* Withdrawal::mutable_address() {
  ::types::H160* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:types.Withdrawal.address)
  return _msg;
}
inline void Withdrawal::set_allocated_address(::types::H160* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.address_;
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(address);
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.address_ = address;
  // @@protoc_insertion_point(field_set_allocated:types.Withdrawal.address)
}

// .types.H256 amount = 4;
inline bool Withdrawal::_internal_has_amount() const {
  return this != internal_default_instance() && _impl_.amount_ != nullptr;
}
inline bool Withdrawal::has_amount() const {
  return _internal_has_amount();
}
inline void Withdrawal::clear_amount() {
  if (GetArenaForAllocation() == nullptr && _impl_.amount_ != nullptr) {
    delete _impl_.amount_;
  }
  _impl_.amount_ = nullptr;
}
inline const ::types::H256& Withdrawal::_internal_amount() const {
  const ::types::H256* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::H256&>(
      ::types::_H256_default_instance_);
}
inline const ::types::H256& Withdrawal::amount() const {
  // @@protoc_insertion_point(field_get:types.Withdrawal.amount)
  return _internal_amount();
}
inline void Withdrawal::unsafe_arena_set_allocated_amount(
    ::types::H256* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.Withdrawal.amount)
}
inline ::types::H256* Withdrawal::release_amount() {
  
  ::types::H256* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::H256* Withdrawal::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:types.Withdrawal.amount)
  
  ::types::H256* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::types::H256* Withdrawal::_internal_mutable_amount() {
  
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::H256>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::types::H256* Withdrawal::mutable_amount() {
  ::types::H256* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:types.Withdrawal.amount)
  return _msg;
}
inline void Withdrawal::set_allocated_amount(::types::H256* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.amount_;
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(amount);
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:types.Withdrawal.amount)
}

// -------------------------------------------------------------------

// ExecutionPayloadV2

// .types.ExecutionPayload payload = 1;
inline bool ExecutionPayloadV2::_internal_has_payload() const {
  return this != internal_default_instance() && _impl_.payload_ != nullptr;
}
inline bool ExecutionPayloadV2::has_payload() const {
  return _internal_has_payload();
}
inline void ExecutionPayloadV2::clear_payload() {
  if (GetArenaForAllocation() == nullptr && _impl_.payload_ != nullptr) {
    delete _impl_.payload_;
  }
  _impl_.payload_ = nullptr;
}
inline const ::types::ExecutionPayload& ExecutionPayloadV2::_internal_payload() const {
  const ::types::ExecutionPayload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::ExecutionPayload&>(
      ::types::_ExecutionPayload_default_instance_);
}
inline const ::types::ExecutionPayload& ExecutionPayloadV2::payload() const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayloadV2.payload)
  return _internal_payload();
}
inline void ExecutionPayloadV2::unsafe_arena_set_allocated_payload(
    ::types::ExecutionPayload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.ExecutionPayloadV2.payload)
}
inline ::types::ExecutionPayload* ExecutionPayloadV2::release_payload() {
  
  ::types::ExecutionPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::ExecutionPayload* ExecutionPayloadV2::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:types.ExecutionPayloadV2.payload)
  
  ::types::ExecutionPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::types::ExecutionPayload* ExecutionPayloadV2::_internal_mutable_payload() {
  
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::ExecutionPayload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::types::ExecutionPayload* ExecutionPayloadV2::mutable_payload() {
  ::types::ExecutionPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayloadV2.payload)
  return _msg;
}
inline void ExecutionPayloadV2::set_allocated_payload(::types::ExecutionPayload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:types.ExecutionPayloadV2.payload)
}

// repeated .types.Withdrawal withdrawals = 2;
inline int ExecutionPayloadV2::_internal_withdrawals_size() const {
  return _impl_.withdrawals_.size();
}
inline int ExecutionPayloadV2::withdrawals_size() const {
  return _internal_withdrawals_size();
}
inline void ExecutionPayloadV2::clear_withdrawals() {
  _impl_.withdrawals_.Clear();
}
inline ::types::Withdrawal* ExecutionPayloadV2::mutable_withdrawals(int index) {
  // @@protoc_insertion_point(field_mutable:types.ExecutionPayloadV2.withdrawals)
  return _impl_.withdrawals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >*
ExecutionPayloadV2::mutable_withdrawals() {
  // @@protoc_insertion_point(field_mutable_list:types.ExecutionPayloadV2.withdrawals)
  return &_impl_.withdrawals_;
}
inline const ::types::Withdrawal& ExecutionPayloadV2::_internal_withdrawals(int index) const {
  return _impl_.withdrawals_.Get(index);
}
inline const ::types::Withdrawal& ExecutionPayloadV2::withdrawals(int index) const {
  // @@protoc_insertion_point(field_get:types.ExecutionPayloadV2.withdrawals)
  return _internal_withdrawals(index);
}
inline ::types::Withdrawal* ExecutionPayloadV2::_internal_add_withdrawals() {
  return _impl_.withdrawals_.Add();
}
inline ::types::Withdrawal* ExecutionPayloadV2::add_withdrawals() {
  ::types::Withdrawal* _add = _internal_add_withdrawals();
  // @@protoc_insertion_point(field_add:types.ExecutionPayloadV2.withdrawals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::types::Withdrawal >&
ExecutionPayloadV2::withdrawals() const {
  // @@protoc_insertion_point(field_list:types.ExecutionPayloadV2.withdrawals)
  return _impl_.withdrawals_;
}

// -------------------------------------------------------------------

// NodeInfoPorts

// uint32 discovery = 1;
inline void NodeInfoPorts::clear_discovery() {
  _impl_.discovery_ = 0u;
}
inline uint32_t NodeInfoPorts::_internal_discovery() const {
  return _impl_.discovery_;
}
inline uint32_t NodeInfoPorts::discovery() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoPorts.discovery)
  return _internal_discovery();
}
inline void NodeInfoPorts::_internal_set_discovery(uint32_t value) {
  
  _impl_.discovery_ = value;
}
inline void NodeInfoPorts::set_discovery(uint32_t value) {
  _internal_set_discovery(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoPorts.discovery)
}

// uint32 listener = 2;
inline void NodeInfoPorts::clear_listener() {
  _impl_.listener_ = 0u;
}
inline uint32_t NodeInfoPorts::_internal_listener() const {
  return _impl_.listener_;
}
inline uint32_t NodeInfoPorts::listener() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoPorts.listener)
  return _internal_listener();
}
inline void NodeInfoPorts::_internal_set_listener(uint32_t value) {
  
  _impl_.listener_ = value;
}
inline void NodeInfoPorts::set_listener(uint32_t value) {
  _internal_set_listener(value);
  // @@protoc_insertion_point(field_set:types.NodeInfoPorts.listener)
}

// -------------------------------------------------------------------

// NodeInfoReply

// string id = 1;
inline void NodeInfoReply::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::id() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfoReply::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.id)
}
inline std::string* NodeInfoReply::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.id)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_id() const {
  return _impl_.id_.Get();
}
inline void NodeInfoReply::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfoReply::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfoReply::release_id() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.id)
  return _impl_.id_.Release();
}
inline void NodeInfoReply::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.id)
}

// string name = 2;
inline void NodeInfoReply::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::name() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfoReply::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.name)
}
inline std::string* NodeInfoReply::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.name)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NodeInfoReply::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfoReply::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfoReply::release_name() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.name)
  return _impl_.name_.Release();
}
inline void NodeInfoReply::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.name)
}

// string enode = 3;
inline void NodeInfoReply::clear_enode() {
  _impl_.enode_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::enode() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.enode)
  return _internal_enode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfoReply::set_enode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.enode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.enode)
}
inline std::string* NodeInfoReply::mutable_enode() {
  std::string* _s = _internal_mutable_enode();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.enode)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_enode() const {
  return _impl_.enode_.Get();
}
inline void NodeInfoReply::_internal_set_enode(const std::string& value) {
  
  _impl_.enode_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfoReply::_internal_mutable_enode() {
  
  return _impl_.enode_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfoReply::release_enode() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.enode)
  return _impl_.enode_.Release();
}
inline void NodeInfoReply::set_allocated_enode(std::string* enode) {
  if (enode != nullptr) {
    
  } else {
    
  }
  _impl_.enode_.SetAllocated(enode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enode_.IsDefault()) {
    _impl_.enode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.enode)
}

// string enr = 4;
inline void NodeInfoReply::clear_enr() {
  _impl_.enr_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::enr() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.enr)
  return _internal_enr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfoReply::set_enr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.enr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.enr)
}
inline std::string* NodeInfoReply::mutable_enr() {
  std::string* _s = _internal_mutable_enr();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.enr)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_enr() const {
  return _impl_.enr_.Get();
}
inline void NodeInfoReply::_internal_set_enr(const std::string& value) {
  
  _impl_.enr_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfoReply::_internal_mutable_enr() {
  
  return _impl_.enr_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfoReply::release_enr() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.enr)
  return _impl_.enr_.Release();
}
inline void NodeInfoReply::set_allocated_enr(std::string* enr) {
  if (enr != nullptr) {
    
  } else {
    
  }
  _impl_.enr_.SetAllocated(enr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enr_.IsDefault()) {
    _impl_.enr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.enr)
}

// .types.NodeInfoPorts ports = 5;
inline bool NodeInfoReply::_internal_has_ports() const {
  return this != internal_default_instance() && _impl_.ports_ != nullptr;
}
inline bool NodeInfoReply::has_ports() const {
  return _internal_has_ports();
}
inline void NodeInfoReply::clear_ports() {
  if (GetArenaForAllocation() == nullptr && _impl_.ports_ != nullptr) {
    delete _impl_.ports_;
  }
  _impl_.ports_ = nullptr;
}
inline const ::types::NodeInfoPorts& NodeInfoReply::_internal_ports() const {
  const ::types::NodeInfoPorts* p = _impl_.ports_;
  return p != nullptr ? *p : reinterpret_cast<const ::types::NodeInfoPorts&>(
      ::types::_NodeInfoPorts_default_instance_);
}
inline const ::types::NodeInfoPorts& NodeInfoReply::ports() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.ports)
  return _internal_ports();
}
inline void NodeInfoReply::unsafe_arena_set_allocated_ports(
    ::types::NodeInfoPorts* ports) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ports_);
  }
  _impl_.ports_ = ports;
  if (ports) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:types.NodeInfoReply.ports)
}
inline ::types::NodeInfoPorts* NodeInfoReply::release_ports() {
  
  ::types::NodeInfoPorts* temp = _impl_.ports_;
  _impl_.ports_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::types::NodeInfoPorts* NodeInfoReply::unsafe_arena_release_ports() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.ports)
  
  ::types::NodeInfoPorts* temp = _impl_.ports_;
  _impl_.ports_ = nullptr;
  return temp;
}
inline ::types::NodeInfoPorts* NodeInfoReply::_internal_mutable_ports() {
  
  if (_impl_.ports_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::NodeInfoPorts>(GetArenaForAllocation());
    _impl_.ports_ = p;
  }
  return _impl_.ports_;
}
inline ::types::NodeInfoPorts* NodeInfoReply::mutable_ports() {
  ::types::NodeInfoPorts* _msg = _internal_mutable_ports();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.ports)
  return _msg;
}
inline void NodeInfoReply::set_allocated_ports(::types::NodeInfoPorts* ports) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ports_;
  }
  if (ports) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ports);
    if (message_arena != submessage_arena) {
      ports = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ports, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ports_ = ports;
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.ports)
}

// string listenerAddr = 6;
inline void NodeInfoReply::clear_listeneraddr() {
  _impl_.listeneraddr_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::listeneraddr() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.listenerAddr)
  return _internal_listeneraddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfoReply::set_listeneraddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.listeneraddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.listenerAddr)
}
inline std::string* NodeInfoReply::mutable_listeneraddr() {
  std::string* _s = _internal_mutable_listeneraddr();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.listenerAddr)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_listeneraddr() const {
  return _impl_.listeneraddr_.Get();
}
inline void NodeInfoReply::_internal_set_listeneraddr(const std::string& value) {
  
  _impl_.listeneraddr_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfoReply::_internal_mutable_listeneraddr() {
  
  return _impl_.listeneraddr_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfoReply::release_listeneraddr() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.listenerAddr)
  return _impl_.listeneraddr_.Release();
}
inline void NodeInfoReply::set_allocated_listeneraddr(std::string* listeneraddr) {
  if (listeneraddr != nullptr) {
    
  } else {
    
  }
  _impl_.listeneraddr_.SetAllocated(listeneraddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.listeneraddr_.IsDefault()) {
    _impl_.listeneraddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.listenerAddr)
}

// bytes protocols = 7;
inline void NodeInfoReply::clear_protocols() {
  _impl_.protocols_.ClearToEmpty();
}
inline const std::string& NodeInfoReply::protocols() const {
  // @@protoc_insertion_point(field_get:types.NodeInfoReply.protocols)
  return _internal_protocols();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfoReply::set_protocols(ArgT0&& arg0, ArgT... args) {
 
 _impl_.protocols_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.NodeInfoReply.protocols)
}
inline std::string* NodeInfoReply::mutable_protocols() {
  std::string* _s = _internal_mutable_protocols();
  // @@protoc_insertion_point(field_mutable:types.NodeInfoReply.protocols)
  return _s;
}
inline const std::string& NodeInfoReply::_internal_protocols() const {
  return _impl_.protocols_.Get();
}
inline void NodeInfoReply::_internal_set_protocols(const std::string& value) {
  
  _impl_.protocols_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfoReply::_internal_mutable_protocols() {
  
  return _impl_.protocols_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfoReply::release_protocols() {
  // @@protoc_insertion_point(field_release:types.NodeInfoReply.protocols)
  return _impl_.protocols_.Release();
}
inline void NodeInfoReply::set_allocated_protocols(std::string* protocols) {
  if (protocols != nullptr) {
    
  } else {
    
  }
  _impl_.protocols_.SetAllocated(protocols, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.protocols_.IsDefault()) {
    _impl_.protocols_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.NodeInfoReply.protocols)
}

// -------------------------------------------------------------------

// PeerInfo

// string id = 1;
inline void PeerInfo::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& PeerInfo::id() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.PeerInfo.id)
}
inline std::string* PeerInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.id)
  return _s;
}
inline const std::string& PeerInfo::_internal_id() const {
  return _impl_.id_.Get();
}
inline void PeerInfo::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerInfo::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerInfo::release_id() {
  // @@protoc_insertion_point(field_release:types.PeerInfo.id)
  return _impl_.id_.Release();
}
inline void PeerInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.id)
}

// string name = 2;
inline void PeerInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PeerInfo::name() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.PeerInfo.name)
}
inline std::string* PeerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.name)
  return _s;
}
inline const std::string& PeerInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PeerInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerInfo::release_name() {
  // @@protoc_insertion_point(field_release:types.PeerInfo.name)
  return _impl_.name_.Release();
}
inline void PeerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.name)
}

// string enode = 3;
inline void PeerInfo::clear_enode() {
  _impl_.enode_.ClearToEmpty();
}
inline const std::string& PeerInfo::enode() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.enode)
  return _internal_enode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerInfo::set_enode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.enode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.PeerInfo.enode)
}
inline std::string* PeerInfo::mutable_enode() {
  std::string* _s = _internal_mutable_enode();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.enode)
  return _s;
}
inline const std::string& PeerInfo::_internal_enode() const {
  return _impl_.enode_.Get();
}
inline void PeerInfo::_internal_set_enode(const std::string& value) {
  
  _impl_.enode_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerInfo::_internal_mutable_enode() {
  
  return _impl_.enode_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerInfo::release_enode() {
  // @@protoc_insertion_point(field_release:types.PeerInfo.enode)
  return _impl_.enode_.Release();
}
inline void PeerInfo::set_allocated_enode(std::string* enode) {
  if (enode != nullptr) {
    
  } else {
    
  }
  _impl_.enode_.SetAllocated(enode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enode_.IsDefault()) {
    _impl_.enode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.enode)
}

// string enr = 4;
inline void PeerInfo::clear_enr() {
  _impl_.enr_.ClearToEmpty();
}
inline const std::string& PeerInfo::enr() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.enr)
  return _internal_enr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerInfo::set_enr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.enr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.PeerInfo.enr)
}
inline std::string* PeerInfo::mutable_enr() {
  std::string* _s = _internal_mutable_enr();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.enr)
  return _s;
}
inline const std::string& PeerInfo::_internal_enr() const {
  return _impl_.enr_.Get();
}
inline void PeerInfo::_internal_set_enr(const std::string& value) {
  
  _impl_.enr_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerInfo::_internal_mutable_enr() {
  
  return _impl_.enr_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerInfo::release_enr() {
  // @@protoc_insertion_point(field_release:types.PeerInfo.enr)
  return _impl_.enr_.Release();
}
inline void PeerInfo::set_allocated_enr(std::string* enr) {
  if (enr != nullptr) {
    
  } else {
    
  }
  _impl_.enr_.SetAllocated(enr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enr_.IsDefault()) {
    _impl_.enr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.enr)
}

// repeated string caps = 5;
inline int PeerInfo::_internal_caps_size() const {
  return _impl_.caps_.size();
}
inline int PeerInfo::caps_size() const {
  return _internal_caps_size();
}
inline void PeerInfo::clear_caps() {
  _impl_.caps_.Clear();
}
inline std::string* PeerInfo::add_caps() {
  std::string* _s = _internal_add_caps();
  // @@protoc_insertion_point(field_add_mutable:types.PeerInfo.caps)
  return _s;
}
inline const std::string& PeerInfo::_internal_caps(int index) const {
  return _impl_.caps_.Get(index);
}
inline const std::string& PeerInfo::caps(int index) const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.caps)
  return _internal_caps(index);
}
inline std::string* PeerInfo::mutable_caps(int index) {
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.caps)
  return _impl_.caps_.Mutable(index);
}
inline void PeerInfo::set_caps(int index, const std::string& value) {
  _impl_.caps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:types.PeerInfo.caps)
}
inline void PeerInfo::set_caps(int index, std::string&& value) {
  _impl_.caps_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:types.PeerInfo.caps)
}
inline void PeerInfo::set_caps(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.caps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.PeerInfo.caps)
}
inline void PeerInfo::set_caps(int index, const char* value, size_t size) {
  _impl_.caps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.PeerInfo.caps)
}
inline std::string* PeerInfo::_internal_add_caps() {
  return _impl_.caps_.Add();
}
inline void PeerInfo::add_caps(const std::string& value) {
  _impl_.caps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.PeerInfo.caps)
}
inline void PeerInfo::add_caps(std::string&& value) {
  _impl_.caps_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:types.PeerInfo.caps)
}
inline void PeerInfo::add_caps(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.caps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.PeerInfo.caps)
}
inline void PeerInfo::add_caps(const char* value, size_t size) {
  _impl_.caps_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.PeerInfo.caps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PeerInfo::caps() const {
  // @@protoc_insertion_point(field_list:types.PeerInfo.caps)
  return _impl_.caps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PeerInfo::mutable_caps() {
  // @@protoc_insertion_point(field_mutable_list:types.PeerInfo.caps)
  return &_impl_.caps_;
}

// string connLocalAddr = 6;
inline void PeerInfo::clear_connlocaladdr() {
  _impl_.connlocaladdr_.ClearToEmpty();
}
inline const std::string& PeerInfo::connlocaladdr() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.connLocalAddr)
  return _internal_connlocaladdr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerInfo::set_connlocaladdr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connlocaladdr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.PeerInfo.connLocalAddr)
}
inline std::string* PeerInfo::mutable_connlocaladdr() {
  std::string* _s = _internal_mutable_connlocaladdr();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.connLocalAddr)
  return _s;
}
inline const std::string& PeerInfo::_internal_connlocaladdr() const {
  return _impl_.connlocaladdr_.Get();
}
inline void PeerInfo::_internal_set_connlocaladdr(const std::string& value) {
  
  _impl_.connlocaladdr_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerInfo::_internal_mutable_connlocaladdr() {
  
  return _impl_.connlocaladdr_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerInfo::release_connlocaladdr() {
  // @@protoc_insertion_point(field_release:types.PeerInfo.connLocalAddr)
  return _impl_.connlocaladdr_.Release();
}
inline void PeerInfo::set_allocated_connlocaladdr(std::string* connlocaladdr) {
  if (connlocaladdr != nullptr) {
    
  } else {
    
  }
  _impl_.connlocaladdr_.SetAllocated(connlocaladdr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connlocaladdr_.IsDefault()) {
    _impl_.connlocaladdr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.connLocalAddr)
}

// string connRemoteAddr = 7;
inline void PeerInfo::clear_connremoteaddr() {
  _impl_.connremoteaddr_.ClearToEmpty();
}
inline const std::string& PeerInfo::connremoteaddr() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.connRemoteAddr)
  return _internal_connremoteaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerInfo::set_connremoteaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connremoteaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:types.PeerInfo.connRemoteAddr)
}
inline std::string* PeerInfo::mutable_connremoteaddr() {
  std::string* _s = _internal_mutable_connremoteaddr();
  // @@protoc_insertion_point(field_mutable:types.PeerInfo.connRemoteAddr)
  return _s;
}
inline const std::string& PeerInfo::_internal_connremoteaddr() const {
  return _impl_.connremoteaddr_.Get();
}
inline void PeerInfo::_internal_set_connremoteaddr(const std::string& value) {
  
  _impl_.connremoteaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerInfo::_internal_mutable_connremoteaddr() {
  
  return _impl_.connremoteaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerInfo::release_connremoteaddr() {
  // @@protoc_insertion_point(field_release:types.PeerInfo.connRemoteAddr)
  return _impl_.connremoteaddr_.Release();
}
inline void PeerInfo::set_allocated_connremoteaddr(std::string* connremoteaddr) {
  if (connremoteaddr != nullptr) {
    
  } else {
    
  }
  _impl_.connremoteaddr_.SetAllocated(connremoteaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connremoteaddr_.IsDefault()) {
    _impl_.connremoteaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:types.PeerInfo.connRemoteAddr)
}

// bool connIsInbound = 8;
inline void PeerInfo::clear_connisinbound() {
  _impl_.connisinbound_ = false;
}
inline bool PeerInfo::_internal_connisinbound() const {
  return _impl_.connisinbound_;
}
inline bool PeerInfo::connisinbound() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.connIsInbound)
  return _internal_connisinbound();
}
inline void PeerInfo::_internal_set_connisinbound(bool value) {
  
  _impl_.connisinbound_ = value;
}
inline void PeerInfo::set_connisinbound(bool value) {
  _internal_set_connisinbound(value);
  // @@protoc_insertion_point(field_set:types.PeerInfo.connIsInbound)
}

// bool connIsTrusted = 9;
inline void PeerInfo::clear_connistrusted() {
  _impl_.connistrusted_ = false;
}
inline bool PeerInfo::_internal_connistrusted() const {
  return _impl_.connistrusted_;
}
inline bool PeerInfo::connistrusted() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.connIsTrusted)
  return _internal_connistrusted();
}
inline void PeerInfo::_internal_set_connistrusted(bool value) {
  
  _impl_.connistrusted_ = value;
}
inline void PeerInfo::set_connistrusted(bool value) {
  _internal_set_connistrusted(value);
  // @@protoc_insertion_point(field_set:types.PeerInfo.connIsTrusted)
}

// bool connIsStatic = 10;
inline void PeerInfo::clear_connisstatic() {
  _impl_.connisstatic_ = false;
}
inline bool PeerInfo::_internal_connisstatic() const {
  return _impl_.connisstatic_;
}
inline bool PeerInfo::connisstatic() const {
  // @@protoc_insertion_point(field_get:types.PeerInfo.connIsStatic)
  return _internal_connisstatic();
}
inline void PeerInfo::_internal_set_connisstatic(bool value) {
  
  _impl_.connisstatic_ = value;
}
inline void PeerInfo::set_connisstatic(bool value) {
  _internal_set_connisstatic(value);
  // @@protoc_insertion_point(field_set:types.PeerInfo.connIsStatic)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace types

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_types_2ftypes_2eproto
